Object.defineProperty(exports, '__esModule', {
  value: true
});

var core = require('@urql/core');

var react = require('react');

var wonka = require('wonka'); // but not to error catastrophically if someone is just playing around


var defaultClient = core.createClient({
  url: '/graphql'
});
var Context = react.createContext(defaultClient);
var Provider = Context.Provider;
var Consumer = Context.Consumer;
Context.displayName = 'UrqlContext';
var hasWarnedAboutDefault = false;

function useClient() {
  var client = react.useContext(Context);

  if (process.env.NODE_ENV !== 'production' && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = true;
    console.warn("Default Client: No client has been specified using urql's Provider." + 'This means that urql will be falling back to defaults including making ' + 'requests to `/graphql`.\n' + "If that's not what you want, please create a client and add a Provider.");
  }

  return client;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var initialState = {
  fetching: false,
  stale: false,
  error: undefined,
  data: undefined,
  extensions: undefined,
  operation: undefined
};

function isShallowDifferent(a, b) {
  if (typeof a != 'object' || typeof b != 'object') {
    return a !== b;
  }

  for (var x in a) {
    if (!(x in b)) {
      return true;
    }
  }

  for (var x$1 in b) {
    if (a[x$1] !== b[x$1]) {
      return true;
    }
  }

  return false;
}

function computeNextState(prevState, result) {
  var newState = _extends({}, prevState, result, {
    data: result.data !== undefined || result.error ? result.data : prevState.data,
    fetching: !!result.fetching,
    stale: !!result.stale
  });

  return isShallowDifferent(prevState, newState) ? newState : prevState;
}

function hasDepsChanged(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    if (a[i] !== b[i]) {
      return true;
    }
  }

  return false;
}

function useMutation(query) {
  var isMounted = react.useRef(true);
  var client = useClient();
  var ref = react.useState(initialState);
  var state = ref[0];
  var setState = ref[1];
  var executeMutation = react.useCallback(function (variables, context) {
    setState(_extends({}, initialState, {
      fetching: true
    }));
    return wonka.toPromise(client.executeMutation(core.createRequest(query, variables), context || {})).then(function (result) {
      if (isMounted.current) {
        setState({
          fetching: false,
          stale: !!result.stale,
          data: result.data,
          error: result.error,
          extensions: result.extensions,
          operation: result.operation
        });
      }

      return result;
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [client, query, setState]);
  react.useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  return [state, executeMutation];
}
/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */


function useRequest(query, variables) {
  var prev = react.useRef(undefined);
  return react.useMemo(function () {
    var request = core.createRequest(query, variables); // We manually ensure reference equality if the key hasn't changed

    if (prev.current !== undefined && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }, [query, variables]);
}

function getCacheForClient(client) {
  if (!client._react) {
    var reclaim = new Set();
    var map = new Map();

    if (client.operations$
    /* not available in mocks */
    ) {
        wonka.subscribe(function (operation) {
          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {
            reclaim.delete(operation.key);
            map.delete(operation.key);
          }
        })(client.operations$);
      }

    client._react = {
      get: function get(key) {
        return map.get(key);
      },
      set: function set(key, value) {
        reclaim.delete(key);
        map.set(key, value);
      },
      dispose: function dispose(key) {
        reclaim.add(key);
      }
    };
  }

  return client._react;
}

function isSuspense(client, context) {
  return client.suspense && (!context || context.suspense !== false);
}

function useQuery(args) {
  var client = useClient();
  var cache = getCacheForClient(client);
  var suspense = isSuspense(client, args.context);
  var request = useRequest(args.query, args.variables);
  var source = react.useMemo(function () {
    if (args.pause) {
      return null;
    }

    var source = client.executeQuery(request, _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context));
    return suspense ? wonka.onPush(function (result) {
      cache.set(request.key, result);
    })(source) : source;
  }, [cache, client, request, suspense, args.pause, args.requestPolicy, args.context]);
  var getSnapshot = react.useCallback(function (source, suspense) {
    if (!source) {
      return {
        fetching: false
      };
    }

    var result = cache.get(request.key);

    if (!result) {
      var resolve;
      var subscription = wonka.subscribe(function (_result) {
        result = _result;

        if (resolve) {
          resolve(result);
        }
      })(wonka.takeWhile(function () {
        return suspense && !resolve || !result;
      })(source));

      if (result == null && suspense) {
        var promise = new Promise(function (_resolve) {
          resolve = _resolve;
        });
        cache.set(request.key, promise);
        throw promise;
      } else {
        subscription.unsubscribe();
      }
    } else if (suspense && result != null && 'then' in result) {
      throw result;
    }

    return result || {
      fetching: true
    };
  }, [cache, request]);
  var deps = [client, request, args.requestPolicy, args.context, args.pause];
  var ref = react.useState(function () {
    return [source, computeNextState(initialState, getSnapshot(source, suspense)), deps];
  });
  var state = ref[0];
  var setState = ref[1];
  var currentResult = state[1];

  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([source, currentResult = computeNextState(state[1], getSnapshot(source, suspense)), deps]);
  }

  react.useEffect(function () {
    var source = state[0];
    var request = state[2][1];
    var hasResult = false;

    function updateResult(result) {
      hasResult = true;
      setState(function (state) {
        var nextResult = computeNextState(state[1], result);
        return state[1] !== nextResult ? [state[0], nextResult, state[2]] : state;
      });
    }

    if (source) {
      var subscription = wonka.subscribe(updateResult)(wonka.onEnd(function () {
        updateResult({
          fetching: false
        });
      })(source));

      if (!hasResult) {
        updateResult({
          fetching: true
        });
      }

      return function () {
        cache.dispose(request.key);
        subscription.unsubscribe();
      };
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [cache, state[0], state[2][1]]);
  var executeQuery = react.useCallback(function (opts) {
    var context = _extends({}, {
      requestPolicy: args.requestPolicy
    }, args.context, opts);

    setState(function (state) {
      var source = suspense ? wonka.onPush(function (result) {
        cache.set(request.key, result);
      })(client.executeQuery(request, context)) : client.executeQuery(request, context);
      return [source, state[1], deps];
    });
  }, [client, cache, request, suspense, getSnapshot, args.requestPolicy, args.context]);
  return [currentResult, executeQuery];
}

function useSubscription(args, handler) {
  var client = useClient();
  var request = useRequest(args.query, args.variables);
  var handlerRef = react.useRef(handler);
  handlerRef.current = handler;
  var source = react.useMemo(function () {
    return !args.pause ? client.executeSubscription(request, args.context) : null;
  }, [client, request, args.pause, args.context]);
  var deps = [client, request, args.context, args.pause];
  var ref = react.useState(function () {
    return [source, _extends({}, initialState, {
      fetching: !!source
    }), deps];
  });
  var state = ref[0];
  var setState = ref[1];
  var currentResult = state[1];

  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([source, currentResult = computeNextState(state[1], {
      fetching: !!source
    }), deps]);
  }

  react.useEffect(function () {
    function updateResult(result) {
      setState(function (state) {
        var nextResult = computeNextState(state[1], result);

        if (state[1] === nextResult) {
          return state;
        }

        if (handlerRef.current && state[1].data !== nextResult.data) {
          nextResult.data = handlerRef.current(state[1].data, nextResult.data);
        }

        return [state[0], nextResult, state[2]];
      });
    }

    if (state[0]) {
      return wonka.subscribe(updateResult)(wonka.onEnd(function () {
        updateResult({
          fetching: false
        });
      })(state[0])).unsubscribe;
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [state[0]]); // This is the imperative execute function passed to the user

  var executeSubscription = react.useCallback(function (opts) {
    var source = client.executeSubscription(request, _extends({}, args.context, opts));
    setState(function (state) {
      return [source, state[1], deps];
    });
  }, [client, args.context, request]);
  return [currentResult, executeSubscription];
}

function Mutation(props) {
  var mutation = useMutation(props.query);
  return props.children(_extends({}, mutation[0], {
    executeMutation: mutation[1]
  }));
}

function Query(props) {
  var query = useQuery(props);
  return props.children(_extends({}, query[0], {
    executeQuery: query[1]
  }));
}

function Subscription(props) {
  var subscription = useSubscription(props, props.handler);
  return props.children(_extends({}, subscription[0], {
    executeSubscription: subscription[1]
  }));
}

exports.Consumer = Consumer;
exports.Context = Context;
exports.Mutation = Mutation;
exports.Provider = Provider;
exports.Query = Query;
exports.Subscription = Subscription;
exports.useClient = useClient;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;
Object.keys(core).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return core[k];
    }
  });
});
//# sourceMappingURL=urql.js.map
