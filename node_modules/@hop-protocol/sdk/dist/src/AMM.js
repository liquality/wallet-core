"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __importDefault(require("./Base"));
const ethereum_block_by_date_1 = __importDefault(require("ethereum-block-by-date"));
const shiftBNDecimals_1 = __importDefault(require("./utils/shiftBNDecimals"));
const ethers_1 = require("ethers");
const luxon_1 = require("luxon");
const Swap__factory_1 = require("@hop-protocol/core/contracts/factories/Swap__factory");
const constants_1 = require("./constants");
const utils_1 = require("ethers/lib/utils");
/**
 * Class reprensenting AMM contract
 * @namespace AMM
 */
class AMM extends Base_1.default {
    /**
     * @desc Instantiates AMM instance.
     * Returns a new Hop AMM SDK instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} token - Token model
     * @param {Object} chain - Chain model
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @Returns {Object} Hop AMM instance
     * @example
     *```js
     *import { AMM, Chain } from '@hop-protocol/sdk'
     *
     *const amm = new AMM('mainnet', 'USDC', Chain.Gnosis)
     *```
     */
    constructor(network, tokenSymbol, chain, signer, chainProviders) {
        super(network, signer, chainProviders);
        if (!tokenSymbol) {
            throw new Error('token is required');
        }
        chain = this.toChainModel(chain);
        if (chain) {
            this.chain = chain;
        }
        this.tokenSymbol = tokenSymbol;
    }
    /**
     * @desc Returns hop AMM instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} Hop AMM instance with connected signer.
     * @example
     *```js
     *import { AMM } from '@hop-protocol/sdk'
     *
     *const signer = new Wallet(privateKey)
     *let amm = new AMM(...)
     * // ...
     *amm = amm.connect(signer)
     *```
     */
    connect(signer) {
        return new AMM(this.network, this.tokenSymbol, this.chain, signer, this.chainProviders);
    }
    /**
     * @desc Sends transaction to add liquidity to AMM.
     * @param {Object} amount0Desired - Amount of token #0 in smallest unit
     * @param {Object} amount1Desired - Amount of token #1 in smallest unit
     * @param {number} minToMint - Minimum amount of LP token to mint in order for
     * transaction to be successful.
     * @param {Number} deadline - Order deadline in seconds
     * @returns {Object} Ethers transaction object.
     * @example
     *```js
     *import { AMM } from '@hop-protocol/sdk'
     *
     *const amm = new AMM(...)
     *const tx = await amm.addLiquidity('1000000000000000000', '1000000000000000000', '0')
     *console.log(tx.hash)
     *```
     */
    addLiquidity(amount0Desired, amount1Desired, minToMint = 0, deadline = this.defaultDeadlineSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            const populatedTx = yield this.populateAddLiquidityTx(amount0Desired, amount1Desired, minToMint, deadline);
            return this.sendTransaction(populatedTx, this.chain);
        });
    }
    populateAddLiquidityTx(amount0Desired, amount1Desired, minToMint = 0, deadline = this.defaultDeadlineSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            deadline = this.normalizeDeadline(deadline);
            const amounts = [amount0Desired, amount1Desired];
            const saddleSwap = yield this.getSaddleSwap();
            const payload = [
                amounts,
                minToMint,
                deadline
            ];
            const overrides = yield this.txOverrides(this.chain);
            return saddleSwap.populateTransaction.addLiquidity(...payload, overrides);
        });
    }
    /**
     * @desc Sends transaction to remove liquidity from AMM.
     * @param {Object} liqudityTokenAmount - Amount of LP tokens to burn.
     * @param {Number} amount0Min - Minimum amount of token #0 to receive in order
     * for transaction to be successful.
     * @param {Number} amount1Min - Minimum amount of token #1 to receive in order
     * for transaction to be successful.
     * transaction to be successful.
     * @param {Number} deadline - Order deadline in seconds
     * @returns {Object} Ethers transaction object.
     * @example
     *```js
     *import { AMM } from '@hop-protocol/sdk'
     *
     *const amm = new AMM(...)
     *const tx = await amm.removeLiquidity('1000000000000000000', '0', '0')
     *console.log(tx.hash)
     *```
     */
    removeLiquidity(liquidityTokenAmount, amount0Min = 0, amount1Min = 0, deadline = this.defaultDeadlineSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            const populatedTx = yield this.populateRemoveLiquidityTx(liquidityTokenAmount, amount0Min, amount1Min, deadline);
            return this.sendTransaction(populatedTx, this.chain);
        });
    }
    populateRemoveLiquidityTx(liqudityTokenAmount, amount0Min = 0, amount1Min = 0, deadline = this.defaultDeadlineSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            deadline = this.normalizeDeadline(deadline);
            const saddleSwap = yield this.getSaddleSwap();
            const amounts = [amount0Min, amount1Min];
            const payload = [
                liqudityTokenAmount,
                amounts,
                deadline
            ];
            const overrides = yield this.txOverrides(this.chain);
            return saddleSwap.populateTransaction.removeLiquidity(...payload, overrides);
        });
    }
    removeLiquidityOneToken(lpAmount, tokenIndex, amountMin = ethers_1.BigNumber.from(0), deadline = this.defaultDeadlineSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            deadline = this.normalizeDeadline(deadline);
            const saddleSwap = yield this.getSaddleSwap();
            const payload = [
                lpAmount,
                tokenIndex,
                amountMin,
                deadline
            ];
            const overrides = yield this.txOverrides(this.chain);
            return saddleSwap.removeLiquidityOneToken(...payload, overrides);
        });
    }
    removeLiquidityImbalance(amount0, amount1, maxBurnAmount = ethers_1.BigNumber.from(0), deadline = this.defaultDeadlineSeconds) {
        return __awaiter(this, void 0, void 0, function* () {
            deadline = this.normalizeDeadline(deadline);
            const saddleSwap = yield this.getSaddleSwap();
            const amounts = [amount0, amount1];
            return saddleSwap.removeLiquidityImbalance(amounts, maxBurnAmount, deadline, yield this.txOverrides(this.chain));
        });
    }
    calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const recipient = yield this.getSignerAddress();
            if (!recipient) {
                throw new Error('recipient address is required');
            }
            const saddleSwap = yield this.getSaddleSwap();
            const overrides = yield this.txOverrides(this.chain);
            return saddleSwap.calculateRemoveLiquidityOneToken(recipient, tokenAmount, tokenIndex, overrides);
        });
    }
    // ToDo: Docs
    calculateToHToken(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.calculateSwap(constants_1.TokenIndex.CanonicalToken, constants_1.TokenIndex.HopBridgeToken, amount);
        });
    }
    // ToDo: Docs
    calculateFromHToken(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.calculateSwap(constants_1.TokenIndex.HopBridgeToken, constants_1.TokenIndex.CanonicalToken, amount);
        });
    }
    calculateAddLiquidityMinimum(amount0, amount1) {
        return __awaiter(this, void 0, void 0, function* () {
            const amounts = [amount0, amount1];
            const saddleSwap = yield this.getSaddleSwap();
            const recipient = yield this.getSignerAddress();
            if (!recipient) {
                throw new Error('recipient address is required');
            }
            const isDeposit = true;
            const total = yield this.getReservesTotal();
            if (total.lte(0)) {
                return ethers_1.BigNumber.from(0);
            }
            const overrides = yield this.txOverrides(this.chain);
            return saddleSwap.calculateTokenAmount(recipient, amounts, isDeposit, overrides);
        });
    }
    calculateRemoveLiquidityMinimum(lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const saddleSwap = yield this.getSaddleSwap();
            const recipient = yield this.getSignerAddress();
            if (!recipient) {
                throw new Error('recipient address is required');
            }
            const overrides = yield this.txOverrides(this.chain);
            return saddleSwap.calculateRemoveLiquidity(recipient, lpTokenAmount, overrides);
        });
    }
    calculateRemoveLiquidityMinimumLpTokens(amount0, amount1) {
        return __awaiter(this, void 0, void 0, function* () {
            const amounts = [amount0, amount1];
            const saddleSwap = yield this.getSaddleSwap();
            const recipient = yield this.getSignerAddress();
            if (!recipient) {
                throw new Error('recipient address is required');
            }
            const isDeposit = false;
            return saddleSwap.calculateTokenAmount(recipient, amounts, isDeposit, yield this.txOverrides(this.chain));
        });
    }
    /**
     * @desc Returns the address of the L2 canonical token.
     * @returns {String} address
     */
    getCanonicalTokenAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getL2CanonicalTokenAddress(this.tokenSymbol, this.chain);
        });
    }
    /**
     * @desc Returns the address of the L2 hop token.
     * @returns {String} address
     */
    getHopTokenAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getL2HopBridgeTokenAddress(this.tokenSymbol, this.chain);
        });
    }
    /**
     * @desc Returns the Saddle swap contract instance for the specified chain.
     * @param {Object} chain - Chain name or model
     * @returns {Object} Ethers contract instance.
     */
    getSaddleSwap() {
        return __awaiter(this, void 0, void 0, function* () {
            const saddleSwapAddress = this.getL2SaddleSwapAddress(this.tokenSymbol, this.chain);
            if (!saddleSwapAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(this.chain);
            return Swap__factory_1.Swap__factory.connect(saddleSwapAddress, provider);
        });
    }
    getSwapFee() {
        return __awaiter(this, void 0, void 0, function* () {
            const saddleSwap = yield this.getSaddleSwap();
            const data = yield saddleSwap.swapStorage();
            const poolFeePrecision = 10;
            const swapFee = data.swapFee;
            return Number((0, utils_1.formatUnits)(swapFee.toString(), poolFeePrecision));
        });
    }
    getApr() {
        return __awaiter(this, void 0, void 0, function* () {
            const token = this.toTokenModel(this.tokenSymbol);
            const provider = this.chain.provider;
            const saddleSwap = yield this.getSaddleSwap();
            const [reserve0, reserve1, data, block] = yield Promise.all([
                saddleSwap.getTokenBalance(0),
                saddleSwap.getTokenBalance(1),
                saddleSwap.swapStorage(),
                provider.getBlock('latest')
            ]);
            const endBlockNumber = block.number;
            let startBlockNumber;
            const blockDater = new ethereum_block_by_date_1.default(provider);
            const currentTimestamp = block.timestamp;
            const date = luxon_1.DateTime.fromSeconds(currentTimestamp)
                .minus({ days: 1 })
                .toJSDate();
            const info = yield blockDater.getDate(date);
            if (!info) {
                throw new Error('could not retrieve block number from 24 hours ago');
            }
            startBlockNumber = info.block;
            const tokenSwapEvents = [];
            const perBatch = 1000;
            let endBatchBlockNumber = Math.min(startBlockNumber + perBatch, endBlockNumber);
            while (startBlockNumber < endBlockNumber) {
                tokenSwapEvents.push(...(yield saddleSwap.queryFilter(saddleSwap.filters.TokenSwap(), startBlockNumber, endBatchBlockNumber)));
                startBlockNumber = endBatchBlockNumber;
                endBatchBlockNumber = Math.min(endBatchBlockNumber + perBatch, endBlockNumber);
            }
            const basisPoints = data.swapFee;
            const FEE_DENOMINATOR = '10000000000'; // 10**10
            const decimals = token.decimals;
            let totalFees = ethers_1.BigNumber.from(0);
            for (const event of tokenSwapEvents) {
                const tokensSold = event.args.tokensSold;
                totalFees = totalFees.add(tokensSold
                    .mul(ethers_1.BigNumber.from(basisPoints))
                    .div(ethers_1.BigNumber.from(FEE_DENOMINATOR)));
            }
            const totalLiquidity = reserve0.add(reserve1);
            const totalLiquidityFormatted = Number((0, utils_1.formatUnits)(totalLiquidity, decimals));
            const totalFeesFormatted = Number((0, utils_1.formatUnits)(totalFees, decimals));
            return (totalFeesFormatted * 365) / totalLiquidityFormatted;
        });
    }
    getVirtualPrice() {
        return __awaiter(this, void 0, void 0, function* () {
            const saddleSwap = yield this.getSaddleSwap();
            return saddleSwap.getVirtualPrice();
        });
    }
    getPriceImpact(amount0, amount1) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = this.toTokenModel(this.tokenSymbol);
            const decimals = token.decimals;
            const saddleSwap = yield this.getSaddleSwap();
            const [virtualPrice, depositLpTokenAmount] = yield Promise.all([
                this.getVirtualPrice(),
                this.calculateAddLiquidityMinimum(amount0, amount1)
            ]);
            let tokenInputSum = ethers_1.BigNumber.from(amount0.toString()).add(ethers_1.BigNumber.from(amount1.toString()));
            // convert to 18 decimals
            tokenInputSum = (0, shiftBNDecimals_1.default)(tokenInputSum, 18 - decimals);
            return this.calculatePriceImpact(tokenInputSum, depositLpTokenAmount, virtualPrice, false);
        });
    }
    getRemoveLiquidityPriceImpact(amount0, amount1) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = this.toTokenModel(this.tokenSymbol);
            const decimals = token.decimals;
            const saddleSwap = yield this.getSaddleSwap();
            const [virtualPrice, withdrawLpTokenAmount] = yield Promise.all([
                this.getVirtualPrice(),
                this.calculateRemoveLiquidityMinimumLpTokens(amount0, amount1)
            ]);
            let tokenInputSum = ethers_1.BigNumber.from(amount0.toString()).add(ethers_1.BigNumber.from(amount1.toString()));
            // convert to 18 decimals
            tokenInputSum = (0, shiftBNDecimals_1.default)(tokenInputSum, 18 - decimals);
            return this.calculatePriceImpact(withdrawLpTokenAmount, tokenInputSum, virtualPrice, true);
        });
    }
    calculateSwap(fromIndex, toIndex, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const saddleSwap = yield this.getSaddleSwap();
            return saddleSwap.calculateSwap(fromIndex, toIndex, amount);
        });
    }
    /**
     * @readonly
     * @desc The default deadline to use in seconds.
     * @returns {Number} Deadline in seconds
     */
    get defaultDeadlineSeconds() {
        const defaultDeadlineMinutes = 30;
        return (Date.now() / 1000 + defaultDeadlineMinutes * 60) | 0;
    }
    /**
     * @desc Truncate any decimal places in deadline unix timestamp.
     * @param {Number} deadline - deadline timestamp
     * @returns {Number} Deadline in seconds
     */
    normalizeDeadline(deadline) {
        return parseInt(deadline.toString(), 10);
    }
    isHighPriceImpact(priceImpact) {
        // assumes that priceImpact has 18d precision
        const negOne = ethers_1.BigNumber.from(10)
            .pow(18 - 2)
            .mul(-1);
        return priceImpact.lte(negOne);
    }
    calculatePriceImpact(tokenInputAmount, // assumed to be 18d precision
    tokenOutputAmount, virtualPrice = ethers_1.BigNumber.from(10).pow(18), isWithdraw = false) {
        if (tokenInputAmount.eq(0) && tokenOutputAmount.eq(0)) {
            return ethers_1.BigNumber.from(0);
        }
        if (isWithdraw) {
            return tokenOutputAmount
                .mul(ethers_1.BigNumber.from(10).pow(36))
                .div(tokenInputAmount.mul(virtualPrice))
                .sub(ethers_1.BigNumber.from(10).pow(18));
        }
        return tokenInputAmount.gt(0)
            ? virtualPrice
                .mul(tokenOutputAmount)
                .div(tokenInputAmount)
                .sub(ethers_1.BigNumber.from(10).pow(18))
            : ethers_1.constants.Zero;
    }
    getReserves() {
        return __awaiter(this, void 0, void 0, function* () {
            const saddleSwap = yield this.getSaddleSwap();
            return Promise.all([
                saddleSwap.getTokenBalance(0),
                saddleSwap.getTokenBalance(1)
            ]);
        });
    }
    getReservesTotal() {
        return __awaiter(this, void 0, void 0, function* () {
            const [reserve0, reserve1] = yield this.getReserves();
            return reserve0.add(reserve1);
        });
    }
    calculateAmountsForLpToken(lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = this.signer
                ? yield this.getSignerAddress()
                : ethers_1.constants.AddressZero;
            const saddleSwap = yield this.getSaddleSwap();
            return saddleSwap.calculateRemoveLiquidity(account, lpTokenAmount, yield this.txOverrides(this.chain));
        });
    }
    calculateTotalAmountForLpToken(lpTokenAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const amounts = yield this.calculateAmountsForLpToken(lpTokenAmount);
            return amounts[0].add(amounts[1]);
        });
    }
}
exports.default = AMM;
