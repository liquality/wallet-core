"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Event = void 0;
const Base_1 = __importDefault(require("../Base"));
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const HopBridge_1 = __importDefault(require("../HopBridge"));
const wait_1 = __importDefault(require("../utils/wait"));
/**
 * @desc Event types for transaction watcher.
 */
var Event;
(function (Event) {
    Event["Receipt"] = "receipt";
    Event["SourceTxReceipt"] = "sourceTxReceipt";
    Event["DestinationTxReceipt"] = "destinationTxReceipt";
})(Event = exports.Event || (exports.Event = {}));
class BaseWatcher extends Base_1.default {
    constructor(config) {
        super(config.network, config.signer, config.chainProviders);
        this.pollDelayMs = 10 * 1000;
        this.options = {};
        const { token, sourceTxHash, sourceChain, destinationChain, options } = config;
        this.token = this.toTokenModel(token);
        this.sourceTxHash = sourceTxHash;
        this.sourceChain = this.toChainModel(sourceChain);
        this.destinationChain = this.toChainModel(destinationChain);
        this.options = options;
        this.ee = new eventemitter3_1.default();
    }
    startBase() {
        return __awaiter(this, void 0, void 0, function* () {
            this.bridge = new HopBridge_1.default(this.network, this.signer, this.token);
            const receipt = yield this.sourceChain.provider.waitForTransaction(this.sourceTxHash);
            yield this.emitSourceTxEvent(receipt);
            if (!receipt.status) {
                return;
            }
            const sourceTx = yield this.sourceChain.provider.getTransaction(this.sourceTxHash);
            const sourceBlock = yield this.sourceChain.provider.getBlock(sourceTx.blockNumber);
            if (!sourceBlock) {
                return;
            }
            this.sourceTx = sourceTx;
            this.sourceBlock = sourceBlock;
            this.sourceReceipt = receipt;
        });
    }
    poll(pollFn) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!pollFn) {
                    return;
                }
                let res = false;
                while (!res) {
                    res = yield pollFn();
                    yield (0, wait_1.default)(this.pollDelayMs);
                }
            }
            catch (err) {
                this.ee.emit('error', err);
            }
        });
    }
    emitSourceTxEvent(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ee.emit(Event.Receipt, { chain: this.sourceChain, receipt });
            this.ee.emit(Event.SourceTxReceipt, { chain: this.sourceChain, receipt });
        });
    }
    emitDestTxEvent(destTx, data = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!destTx) {
                return false;
            }
            const destTxReceipt = yield this.destinationChain.provider.waitForTransaction(destTx.hash);
            this.ee.emit(Event.Receipt, Object.assign({
                chain: this.destinationChain,
                receipt: destTxReceipt
            }, data));
            this.ee.emit(Event.DestinationTxReceipt, Object.assign({
                chain: this.destinationChain,
                receipt: destTxReceipt
            }, data));
            return true;
        });
    }
}
exports.default = BaseWatcher;
