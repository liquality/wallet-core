"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __importDefault(require("./Base"));
const Token_1 = __importDefault(require("./models/Token"));
const Token_2 = __importDefault(require("./Token"));
const ArbERC20__factory_1 = require("@hop-protocol/core/contracts/factories/ArbERC20__factory");
const ArbitrumGlobalInbox__factory_1 = require("@hop-protocol/core/contracts/factories/ArbitrumGlobalInbox__factory");
const models_1 = require("./models");
const ethers_1 = require("ethers");
const L1HomeAMBNativeToErc20__factory_1 = require("@hop-protocol/core/contracts/factories/L1HomeAMBNativeToErc20__factory");
const L1OptimismTokenBridge__factory_1 = require("@hop-protocol/core/contracts/factories/L1OptimismTokenBridge__factory");
const L1PolygonPosRootChainManager__factory_1 = require("@hop-protocol/core/contracts/factories/L1PolygonPosRootChainManager__factory");
const L1XDaiForeignOmniBridge__factory_1 = require("@hop-protocol/core/contracts/factories/L1XDaiForeignOmniBridge__factory");
const L2OptimismTokenBridge__factory_1 = require("@hop-protocol/core/contracts/factories/L2OptimismTokenBridge__factory");
const L2PolygonChildERC20__factory_1 = require("@hop-protocol/core/contracts/factories/L2PolygonChildERC20__factory");
const L2XDaiToken__factory_1 = require("@hop-protocol/core/contracts/factories/L2XDaiToken__factory");
const utils_1 = require("ethers/lib/utils");
const config_1 = require("./config");
/**
 * Class reprensenting Canonical Token Bridge.
 * @namespace CanonicalBridge
 */
class CanonicalBridge extends Base_1.default {
    /**
     * @desc Instantiates Canonical Token Bridge.
     * Returns a new Canonical Token Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} chain - Chain model
     * @returns {Object} CanonicalBridge SDK instance.
     * @example
     *```js
     *import { CanonicalHop, Chain } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new CanonicalBridge('kovan', signer, 'USDC', Chain.Optimism)
     *```
     */
    constructor(network, signer, token, chain, chainProviders) {
        super(network, signer, chainProviders);
        if (!token) {
            throw new Error('token symbol is required');
        }
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        if (signer) {
            this.signer = signer;
        }
        this.chain = chain;
        if (token instanceof Token_1.default) {
            this.tokenSymbol = token.symbol;
        }
        else if (typeof token === 'string') {
            this.tokenSymbol = token;
        }
        else {
            console.log('token: ', token);
            throw new Error('Invalid token');
        }
    }
    /**
     * @desc Return address of L1 canonical token bridge.
     * @return {String} L1 canonical token bridge address
     */
    get address() {
        if (!this.tokenSymbol) {
            return null;
        }
        if (!this.chain) {
            return null;
        }
        return this.getL1CanonicalBridgeAddress(this.tokenSymbol, this.chain);
    }
    /**
     * @desc Returns canonical bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New CanonicalBridge SDK instance with connected signer.
     */
    connect(signer) {
        return new CanonicalBridge(this.network, signer, this.tokenSymbol, this.chain, this.chainProviders);
    }
    getDepositApprovalAddress(chain) {
        chain = this.chain || this.toChainModel(chain);
        let spender = this.getL1CanonicalBridgeAddress(this.tokenSymbol, chain);
        if (chain.equals(models_1.Chain.Polygon)) {
            spender = this.getL1PosErc20PredicateAddress(this.tokenSymbol, chain);
        }
        return spender;
    }
    /**
     * @desc Sends transaction to approve tokens for canonical token bridge deposit.
     * Will only send approval transaction if necessary.
     * @param {Object} amount - Token amount to approve.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    approveDeposit(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            if (chain) {
                chain = this.toChainModel(chain);
            }
            else {
                chain = this.chain;
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            const l1CanonicalToken = this.getL1Token().connect(provider);
            const spender = this.getDepositApprovalAddress(chain);
            if (!spender) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            return l1CanonicalToken.approve(spender, amount);
        });
    }
    /**
     * @desc Sends transaction to canonical token bridge to deposit tokens into L2.
     * @param {Object} amount - Token amount to deposit.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    deposit(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            if (chain) {
                chain = this.toChainModel(chain);
            }
            else {
                chain = this.chain;
            }
            if (!chain) {
                throw new Error('chain is required');
            }
            const recipient = yield this.getSignerAddress();
            const bridgeAddress = this.getL1CanonicalBridgeAddress(this.tokenSymbol, chain);
            if (!bridgeAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            const tokenAddress = this.getL1CanonicalTokenAddress(this.tokenSymbol, models_1.Chain.Ethereum);
            if (!tokenAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            if (chain.equals(models_1.Chain.Gnosis)) {
                const bridge = yield this.getContract(L1XDaiForeignOmniBridge__factory_1.L1XDaiForeignOmniBridge__factory, bridgeAddress, provider);
                // await this.checkMaxTokensAllowed(chain, bridge, amount)
                return bridge.relayTokens(tokenAddress, recipient, amount, {
                    // Gnosis requires a higher gas limit
                    gasLimit: 300000
                });
            }
            else if (chain.equals(models_1.Chain.Optimism)) {
                const l2TokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!l2TokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(L1OptimismTokenBridge__factory_1.L1OptimismTokenBridge__factory, bridgeAddress, provider);
                yield this.checkMaxTokensAllowed(chain, bridge, amount);
                return bridge.deposit(tokenAddress, l2TokenAddress, recipient, amount);
            }
            else if (chain.equals(models_1.Chain.Arbitrum)) {
                const arbChain = this.getArbChainAddress(this.tokenSymbol, chain);
                const bridge = yield this.getContract(ArbitrumGlobalInbox__factory_1.ArbitrumGlobalInbox__factory, bridgeAddress, provider);
                yield this.checkMaxTokensAllowed(chain, bridge, amount);
                return bridge.depositERC20Message(arbChain, tokenAddress, recipient, amount);
            }
            else if (chain.equals(models_1.Chain.Polygon)) {
                const bridgeAddress = this.getL1PosRootChainManagerAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(L1PolygonPosRootChainManager__factory_1.L1PolygonPosRootChainManager__factory, bridgeAddress, provider);
                const coder = ethers_1.ethers.utils.defaultAbiCoder;
                const payload = coder.encode(['uint256'], [amount]);
                return bridge.depositFor(recipient, tokenAddress, payload);
            }
            else {
                throw new Error('not implemented');
            }
        });
    }
    getWithdrawApprovalAddress(chain) {
        chain = this.chain || this.toChainModel(chain);
        let spender = this.getL2CanonicalBridgeAddress(this.tokenSymbol, chain);
        if (chain.equals(models_1.Chain.Polygon)) {
            spender = this.getL1PosErc20PredicateAddress(this.tokenSymbol, chain);
        }
        return spender;
    }
    /**
     * @desc Sends transaction to approve tokens for canonical token bridge withdrawal.
     * Will only send approval transaction if necessary.
     * @param {Object} amount - Token amount to approve.
     * @returns {Object} Ethers transaction object.
     */
    approveWithdraw(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            // no approval needed
            if (this.chain.equals(models_1.Chain.Polygon)) {
                return;
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            const token = this.getCanonicalToken(this.chain).connect(provider);
            const spender = this.getWithdrawApprovalAddress(this.chain);
            if (!spender) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            return token.approve(spender, amount);
        });
    }
    /**
     * @desc Sends transaction to L2 canonical token bridge to withdraw tokens into L1.
     * @param {Object} amount - Token amount to withdraw.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    withdraw(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            if (chain) {
                chain = this.toChainModel(chain);
            }
            else {
                chain = this.chain;
            }
            if (!chain) {
                throw new Error('chain is required');
            }
            const recipient = yield this.getSignerAddress();
            const provider = yield this.getSignerOrProvider(chain);
            if (chain.equals(models_1.Chain.Gnosis)) {
                const bridgeAddress = this.getL2CanonicalBridgeAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const tokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!tokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(L2XDaiToken__factory_1.L2XDaiToken__factory, tokenAddress, provider);
                return bridge.transferAndCall(bridgeAddress, amount, '0x', {
                    // Gnosis requires a higher gas limit
                    gasLimit: 400000
                });
            }
            else if (chain.equals(models_1.Chain.Optimism)) {
                const bridgeAddress = this.getL2CanonicalBridgeAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const l1TokenAddress = this.getL1CanonicalTokenAddress(this.tokenSymbol, models_1.Chain.Ethereum);
                if (!l1TokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${models_1.Chain.Ethereum.slug}" is unsupported`);
                }
                const tokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!tokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(L2OptimismTokenBridge__factory_1.L2OptimismTokenBridge__factory, bridgeAddress, provider);
                return bridge.withdraw(l1TokenAddress, tokenAddress, amount, {
                    // optimism requires a high gas limit and 0 gas price
                    gasLimit: 1000000,
                    gasPrice: 0
                });
            }
            else if (chain.equals(models_1.Chain.Arbitrum)) {
                const bridgeAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = ArbERC20__factory_1.ArbERC20__factory.connect(bridgeAddress, provider);
                return bridge.withdraw(recipient, amount);
            }
            else if (chain.equals(models_1.Chain.Polygon)) {
                const tokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!tokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const token = L2PolygonChildERC20__factory_1.L2PolygonChildERC20__factory.connect(tokenAddress, provider);
                return token.withdraw(amount);
            }
            else {
                throw new Error('not implemented');
            }
        });
    }
    /**
     * @desc Sends transaction to finalize withdrawal.
     * This call is necessary on Polygon to finalize L2 withdrawal into L1 on
     * certain chains. Will only send transaction if necessary.
     * @param {String} txHash - Transaction hash proving token burn on L2.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    exit(txHash, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const recipient = yield this.getSignerAddress();
            const { MaticPOSClient } = require('@maticnetwork/maticjs');
            const Web3 = require('web3');
            const maticPOSClient = new MaticPOSClient({
                network: models_1.Chain.Ethereum.chainId === 1 ? 'mainnet' : 'testnet',
                maticProvider: new Web3.providers.HttpProvider(models_1.Chain.Polygon.rpcUrl),
                parentProvider: new Web3.providers.HttpProvider(models_1.Chain.Ethereum.rpcUrl)
            });
            const tx = yield maticPOSClient.exitERC20(txHash, {
                from: recipient,
                encodeAbi: true
            });
            const provider = yield this.getSignerOrProvider(chain);
            return provider.sendTransaction({
                to: tx.to,
                value: tx.value,
                data: tx.data,
                gasLimit: tx.gas
            });
        });
    }
    /**
     * @desc Checks if the amount of tokens is allowed by the canonical token bridge,
     * otherwise throw an error.
     * @param {Object} chain - Chain model.
     * @param {Object} canonicalBridge - Ethers contract object for canonical token bridge.
     * @param {Object} amount - Token amount.
     */
    checkMaxTokensAllowed(chain, canonicalBridge, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (chain.equals(models_1.Chain.Gnosis)) {
                const l1CanonicalToken = this.getL1Token();
                const maxPerTx = yield (canonicalBridge === null || canonicalBridge === void 0 ? void 0 : canonicalBridge.maxPerTx());
                const formattedMaxPerTx = Number((0, utils_1.formatUnits)(maxPerTx.toString(), l1CanonicalToken.decimals));
                const formattedAmount = Number((0, utils_1.formatUnits)(amount.toString(), l1CanonicalToken.decimals));
                if (formattedAmount > formattedMaxPerTx) {
                    throw new Error(`Max allowed by Gnosis Bridge is ${formattedMaxPerTx} tokens`);
                }
            }
        });
    }
    // Gnosis AMB bridge
    getAmbBridge(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain || this.chain);
            if (chain.equals(models_1.Chain.Ethereum)) {
                const address = this.getL1AmbBridgeAddress(this.tokenSymbol, models_1.Chain.Gnosis);
                const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
                return this.getContract(L1HomeAMBNativeToErc20__factory_1.L1HomeAMBNativeToErc20__factory, address, provider);
            }
            const address = this.getL2AmbBridgeAddress(this.tokenSymbol, models_1.Chain.Gnosis);
            const provider = yield this.getSignerOrProvider(models_1.Chain.Gnosis);
            return this.getContract(L1HomeAMBNativeToErc20__factory_1.L1HomeAMBNativeToErc20__factory, address, provider);
        });
    }
    getL2CanonicalBridge() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = this.getL2CanonicalBridgeAddress(this.tokenSymbol, this.chain);
            if (!address) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(this.chain);
            let factory;
            if (this.chain.equals(models_1.Chain.Polygon)) {
                factory = L2PolygonChildERC20__factory_1.L2PolygonChildERC20__factory;
            }
            else if (this.chain.equals(models_1.Chain.Gnosis)) {
                factory = L2XDaiToken__factory_1.L2XDaiToken__factory;
            }
            else if (this.chain.equals(models_1.Chain.Arbitrum)) {
                factory = ArbERC20__factory_1.ArbERC20__factory;
            }
            else if (this.chain.equals(models_1.Chain.Optimism)) {
                factory = L2OptimismTokenBridge__factory_1.L2OptimismTokenBridge__factory;
            }
            return this.getContract(factory, address, provider);
        });
    }
    getL1CanonicalBridge() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = this.getL1CanonicalBridgeAddress(this.tokenSymbol, this.chain);
            if (!address) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            let factory;
            if (this.chain.equals(models_1.Chain.Polygon)) {
                factory = L1PolygonPosRootChainManager__factory_1.L1PolygonPosRootChainManager__factory;
            }
            else if (this.chain.equals(models_1.Chain.Gnosis)) {
                factory = L1XDaiForeignOmniBridge__factory_1.L1XDaiForeignOmniBridge__factory;
            }
            else if (this.chain.equals(models_1.Chain.Arbitrum)) {
                factory = ArbitrumGlobalInbox__factory_1.ArbitrumGlobalInbox__factory;
            }
            else if (this.chain.equals(models_1.Chain.Optimism)) {
                factory = L1OptimismTokenBridge__factory_1.L1OptimismTokenBridge__factory;
            }
            return this.getContract(factory, address, provider);
        });
    }
    // ToDo: Remove duplicated logic after refactoring token getters
    getL1Token() {
        return this.toCanonicalToken(this.tokenSymbol, this.network, models_1.Chain.Ethereum);
    }
    getCanonicalToken(chain) {
        return this.toCanonicalToken(this.tokenSymbol, this.network, chain);
    }
    getL2HopToken(chain) {
        return this.toHopToken(this.tokenSymbol, this.network, chain);
    }
    toCanonicalToken(token, network, chain) {
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        const { name, symbol, decimals, image } = config_1.metadata.tokens[network][token.canonicalSymbol];
        let address;
        if (chain.isL1) {
            const { l1CanonicalToken } = this.getL1CanonicalBridgeAddress(token.symbol, chain.slug);
            address = l1CanonicalToken;
        }
        else {
            const { l2CanonicalToken } = this.getL2CanonicalTokenAddress(token.symbol, chain.slug);
            address = l2CanonicalToken;
        }
        return new Token_2.default(network, chain, address, decimals, symbol, name, image);
    }
    toHopToken(token, network, chain) {
        chain = this.toChainModel(chain);
        if (chain.isL1) {
            throw new Error('Hop tokens do not exist on layer 1');
        }
        let tokenSymbol;
        if (typeof token === 'string') {
            tokenSymbol = token;
        }
        else {
            tokenSymbol = token.symbol;
        }
        const { name, symbol, decimals, image } = config_1.metadata.tokens[network][tokenSymbol];
        const { l2HopBridgeToken } = this.getL2HopBridgeTokenAddress(tokenSymbol, chain.slug);
        return new Token_2.default(network, chain, l2HopBridgeToken, decimals, symbol, name, image);
    }
}
exports.default = CanonicalBridge;
