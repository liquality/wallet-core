"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AMM_1 = __importDefault(require("./AMM"));
const Base_1 = __importDefault(require("./Base"));
const Chain_1 = __importDefault(require("./models/Chain"));
const Token_1 = __importDefault(require("./Token"));
const Token_2 = __importDefault(require("./models/Token"));
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const L1ERC20Bridge__factory_1 = require("@hop-protocol/core/contracts/factories/L1ERC20Bridge__factory");
const L1HomeAMBNativeToErc20__factory_1 = require("@hop-protocol/core/contracts/factories/L1HomeAMBNativeToErc20__factory");
const L2AmmWrapper__factory_1 = require("@hop-protocol/core/contracts/factories/L2AmmWrapper__factory");
const L2Bridge__factory_1 = require("@hop-protocol/core/contracts/factories/L2Bridge__factory");
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
const priceFeed_1 = require("./priceFeed");
const config_1 = require("./config");
const utils_1 = require("ethers/lib/utils");
/**
 * Class representing Hop bridge.
 * @namespace HopBridge
 */
class HopBridge extends Base_1.default {
    /**
     * @desc Instantiates Hop Bridge.
     * Returns a new Hop Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} sourceChain - Source chain model
     * @param {Object} destinationChain - Destination chain model
     * @returns {Object} HopBridge SDK instance.
     * @example
     *```js
     *import { HopBridge, Chain, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new HopBridge('kovan', signer, Token.USDC, Chain.Optimism, Chain.Gnosis)
     *```
     */
    constructor(network, signer, token, chainProviders) {
        super(network, signer, chainProviders);
        /** Default deadline for transfers */
        this.defaultDeadlineMinutes = 7 * 24 * 60; // 1 week
        if (token instanceof Token_1.default || token instanceof Token_2.default) {
            this.tokenSymbol = token.symbol;
        }
        else if (typeof token === 'string') {
            this.tokenSymbol = token;
        }
        if (!token) {
            throw new Error('token is required');
        }
        this.priceFeed = new priceFeed_1.PriceFeed();
    }
    /**
     * @desc Returns hop bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New HopBridge SDK instance with connected signer.
     * @example
     *```js
     *import { Hop, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *let hop = new Hop()
     * // ...
     *const bridge = hop.bridge(Token.USDC).connect(signer)
     *```
     */
    connect(signer) {
        return new HopBridge(this.network, signer, this.tokenSymbol, this.chainProviders);
    }
    getL1Token() {
        return this.toCanonicalToken(this.tokenSymbol, this.network, Chain_1.default.Ethereum);
    }
    getCanonicalToken(chain) {
        return this.toCanonicalToken(this.tokenSymbol, this.network, chain);
    }
    getL2HopToken(chain) {
        return this.toHopToken(this.tokenSymbol, this.network, chain);
    }
    toCanonicalToken(token, network, chain) {
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        let { name, symbol, decimals, image } = config_1.metadata.tokens[network][token.canonicalSymbol];
        if (chain.equals(Chain_1.default.Gnosis) && token.symbol === constants_1.CanonicalToken.DAI) {
            symbol = constants_1.CanonicalToken.XDAI;
        }
        let address;
        if (chain.isL1) {
            address = this.getL1CanonicalTokenAddress(token.symbol, chain);
        }
        else {
            address = this.getL2CanonicalTokenAddress(token.symbol, chain);
        }
        return new Token_1.default(network, chain, address, decimals, symbol, name, image, this.signer, this.chainProviders);
    }
    toHopToken(token, network, chain) {
        chain = this.toChainModel(chain);
        token = this.toTokenModel(token);
        if (chain.isL1) {
            throw new Error('Hop tokens do not exist on layer 1');
        }
        const { name, decimals, image } = config_1.metadata.tokens[network][token.canonicalSymbol];
        const address = this.getL2HopBridgeTokenAddress(token.symbol, chain);
        return new Token_1.default(network, chain, address, decimals, `h${token.canonicalSymbol}`, `Hop ${name}`, image, this.signer, this.chainProviders);
    }
    /**
     * @desc Send tokens to another chain.
     * @param {String} tokenAmount - Token amount to send denominated in smallest unit.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain, Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *\// send 1 USDC token from Optimism -> Gnosis
     *const tx = await bridge.send('1000000000000000000', Chain.Optimism, Chain.Gnosis)
     *console.log(tx.hash)
     *```
     */
    send(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            const populatedTx = yield this.populateSendTx(tokenAmount, sourceChain, destinationChain, Object.assign(Object.assign({}, options), { checkAllowance: true }));
            let balance;
            const canonicalToken = this.getCanonicalToken(sourceChain);
            if (this.isNativeToken(sourceChain)) {
                balance = yield canonicalToken.getNativeTokenBalance();
            }
            else {
                balance = yield canonicalToken.balanceOf();
            }
            if (balance.lt(tokenAmount)) {
                throw new Error(constants_1.Errors.NotEnoughAllowance);
            }
            const availableLiquidity = yield this.getFrontendAvailableLiquidity(sourceChain, destinationChain);
            const requiredLiquidity = yield this.getRequiredLiquidity(tokenAmount, sourceChain);
            const isAvailable = availableLiquidity.gte(requiredLiquidity);
            if (!isAvailable) {
                throw new Error('Insufficient liquidity available by bonder. Try again in a few minutes');
            }
            this.checkConnectedChain(this.signer, sourceChain);
            return this.sendTransaction(populatedTx, sourceChain);
        });
    }
    populateSendTx(tokenAmount, sourceChain, destinationChain, options = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmount = ethers_1.BigNumber.from(tokenAmount.toString());
            if (!sourceChain) {
                sourceChain = this.sourceChain;
            }
            if (!destinationChain) {
                destinationChain = this.destinationChain;
            }
            if (!sourceChain) {
                throw new Error('source chain is required');
            }
            if (!destinationChain) {
                throw new Error('destination chain is required');
            }
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            tokenAmount = ethers_1.BigNumber.from(tokenAmount.toString());
            // L1 -> L1 or L2
            if (sourceChain.isL1) {
                // L1 -> L1
                if (destinationChain.isL1) {
                    throw new Error('Cannot send from layer 1 to layer 1');
                }
                // L1 -> L2
                return this.populateSendL1ToL2Tx({
                    destinationChain: destinationChain,
                    sourceChain,
                    relayer: (_a = options === null || options === void 0 ? void 0 : options.relayer) !== null && _a !== void 0 ? _a : ethers_1.ethers.constants.AddressZero,
                    relayerFee: (_b = options === null || options === void 0 ? void 0 : options.relayerFee) !== null && _b !== void 0 ? _b : 0,
                    amount: tokenAmount,
                    amountOutMin: (_c = options === null || options === void 0 ? void 0 : options.amountOutMin) !== null && _c !== void 0 ? _c : 0,
                    deadline: options === null || options === void 0 ? void 0 : options.deadline,
                    recipient: options === null || options === void 0 ? void 0 : options.recipient,
                    checkAllowance: options === null || options === void 0 ? void 0 : options.checkAllowance
                });
            }
            // else:
            // L2 -> L1 or L2
            let bonderFee = options === null || options === void 0 ? void 0 : options.bonderFee;
            if (!bonderFee) {
                bonderFee = yield this.getTotalFee(tokenAmount, sourceChain, destinationChain);
            }
            // L2 -> L1
            if (destinationChain.isL1) {
                return this.populateSendL2ToL1Tx({
                    destinationChain: destinationChain,
                    sourceChain,
                    amount: tokenAmount,
                    bonderFee,
                    recipient: options === null || options === void 0 ? void 0 : options.recipient,
                    amountOutMin: options === null || options === void 0 ? void 0 : options.amountOutMin,
                    deadline: options === null || options === void 0 ? void 0 : options.deadline,
                    destinationAmountOutMin: options === null || options === void 0 ? void 0 : options.destinationAmountOutMin,
                    destinationDeadline: options === null || options === void 0 ? void 0 : options.destinationDeadline,
                    checkAllowance: options === null || options === void 0 ? void 0 : options.checkAllowance
                });
            }
            // L2 -> L2
            return this.populateSendL2ToL2Tx({
                destinationChain: destinationChain,
                sourceChain,
                amount: tokenAmount,
                bonderFee,
                recipient: options === null || options === void 0 ? void 0 : options.recipient,
                amountOutMin: options === null || options === void 0 ? void 0 : options.amountOutMin,
                deadline: options === null || options === void 0 ? void 0 : options.deadline,
                destinationAmountOutMin: options === null || options === void 0 ? void 0 : options.destinationAmountOutMin,
                destinationDeadline: options === null || options === void 0 ? void 0 : options.destinationDeadline,
                checkAllowance: options === null || options === void 0 ? void 0 : options.checkAllowance
            });
        });
    }
    estimateSendGasLimit(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const populatedTx = yield this.populateSendTx(tokenAmount, sourceChain, destinationChain, options);
            return this.getEstimatedGasLimit(sourceChain, destinationChain, populatedTx);
        });
    }
    getEstimatedGasLimit(sourceChain, destinationChain, populatedTx) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            if (!populatedTx.from) {
                // a `from` address is required if using only provider (not signer)
                populatedTx.from = yield this.getGasEstimateFromAddress(sourceChain, destinationChain);
            }
            return sourceChain.provider.estimateGas(Object.assign(Object.assign({}, populatedTx), { gasLimit: 500000 }));
        });
    }
    getSendEstimatedGasCost(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            const populatedTx = yield this.populateSendTx(tokenAmount, sourceChain, destinationChain, options);
            const estimatedGasLimit = yield this.getEstimatedGasLimit(sourceChain, destinationChain, populatedTx);
            const gasPrice = yield sourceChain.provider.getGasPrice();
            return gasPrice.mul(estimatedGasLimit);
        });
    }
    // ToDo: Docs
    getSendApprovalAddress(sourceChain, isHTokenTransfer = false) {
        sourceChain = this.toChainModel(sourceChain);
        if (sourceChain.equals(Chain_1.default.Ethereum)) {
            return this.getL1BridgeAddress(this.tokenSymbol, sourceChain);
        }
        const ammWrapperAddress = this.getL2AmmWrapperAddress(this.tokenSymbol, sourceChain);
        const l2BridgeAddress = this.getL2BridgeAddress(this.tokenSymbol, sourceChain);
        return isHTokenTransfer ? l2BridgeAddress : ammWrapperAddress;
    }
    populateSendApprovalTx(tokenAmount, sourceChain, isHTokenTransfer = false) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            const spender = yield this.getSendApprovalAddress(sourceChain, isHTokenTransfer);
            const isNativeToken = this.isNativeToken(sourceChain);
            if (isNativeToken) {
                return null;
            }
            let token;
            if (sourceChain.isL1) {
                token = this.getL1Token();
            }
            else if (isHTokenTransfer) {
                token = this.getL2HopToken(sourceChain);
            }
            else {
                token = this.getCanonicalToken(sourceChain);
            }
            const populatedTx = yield token.populateApproveTx(spender, tokenAmount);
            return populatedTx;
        });
    }
    sendApproval(tokenAmount, sourceChain, destinationChain, isHTokenTransfer = false) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            const populatedTx = yield this.populateSendApprovalTx(tokenAmount, sourceChain, isHTokenTransfer);
            if (populatedTx) {
                this.checkConnectedChain(this.signer, sourceChain);
                return this.sendTransaction(populatedTx, sourceChain);
            }
        });
    }
    // ToDo: Docs
    sendHToken(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            const populatedTx = yield this.populateSendHTokensTx(tokenAmount, sourceChain, destinationChain, options);
            this.checkConnectedChain(this.signer, sourceChain);
            return this.sendTransaction(populatedTx, sourceChain);
        });
    }
    estimateSendHTokensGasLimit(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const populatedTx = yield this.populateSendHTokensTx(tokenAmount, sourceChain, destinationChain, options);
            return this.getEstimatedGasLimit(sourceChain, destinationChain, populatedTx);
        });
    }
    populateSendHTokensTx(tokenAmount, sourceChain, destinationChain, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!sourceChain) {
                throw new Error('source chain is required');
            }
            if (!destinationChain) {
                throw new Error('destination chain is required');
            }
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (sourceChain.isL1 && destinationChain.isL1) {
                throw new Error('sourceChain and destinationChain cannot both be L1');
            }
            else if (!sourceChain.isL1 && !destinationChain.isL1) {
                throw new Error('Sending hToken L2 to L2 is not currently supported');
            }
            if ((options === null || options === void 0 ? void 0 : options.deadline) ||
                (options === null || options === void 0 ? void 0 : options.amountOutMin) ||
                (options === null || options === void 0 ? void 0 : options.destinationDeadline) ||
                (options === null || options === void 0 ? void 0 : options.destinationAmountOutMin)) {
                throw new Error('Invalid sendHToken option');
            }
            let defaultBonderFee = ethers_1.BigNumber.from(0);
            if (!sourceChain.isL1) {
                defaultBonderFee = yield this.getTotalFee(tokenAmount, sourceChain, destinationChain);
            }
            let recipient = (_a = options === null || options === void 0 ? void 0 : options.recipient) !== null && _a !== void 0 ? _a : yield this.getSignerAddress();
            if (!recipient) {
                throw new Error('recipient is required');
            }
            recipient = (0, utils_1.getAddress)(recipient);
            const bonderFee = (options === null || options === void 0 ? void 0 : options.bonderFee)
                ? ethers_1.BigNumber.from(options === null || options === void 0 ? void 0 : options.bonderFee)
                : defaultBonderFee;
            const amountOutMin = ethers_1.BigNumber.from(0);
            const deadline = ethers_1.BigNumber.from(0);
            const relayer = ethers_1.ethers.constants.AddressZero;
            if (sourceChain.isL1) {
                if (bonderFee.gt(0)) {
                    throw new Error('Bonder fee should be 0 when sending hToken to L2');
                }
                const isNativeToken = this.isNativeToken(sourceChain);
                const txOptions = [
                    destinationChain.chainId,
                    recipient,
                    tokenAmount,
                    amountOutMin,
                    deadline,
                    relayer,
                    bonderFee,
                    Object.assign(Object.assign({}, (yield this.txOverrides(Chain_1.default.Ethereum))), { value: isNativeToken ? tokenAmount : undefined })
                ];
                const l1Bridge = yield this.getL1Bridge(sourceChain.provider);
                return l1Bridge.populateTransaction.sendToL2(...txOptions);
            }
            else {
                if (bonderFee.eq(0)) {
                    throw new Error('Send at least the minimum Bonder fee');
                }
                const txOptions = [
                    destinationChain.chainId,
                    recipient,
                    tokenAmount,
                    bonderFee,
                    amountOutMin,
                    deadline,
                    yield this.txOverrides(sourceChain)
                ];
                const l2Bridge = yield this.getL2Bridge(sourceChain, sourceChain.provider);
                return l2Bridge.populateTransaction.send(...txOptions);
            }
        });
    }
    // ToDo: Docs
    getTokenSymbol() {
        return this.tokenSymbol;
    }
    // ToDo: Docs
    getTokenImage() {
        var _a;
        return (_a = this.getL1Token()) === null || _a === void 0 ? void 0 : _a.image;
    }
    // ToDo: Docs
    getSendData(amountIn, sourceChain, destinationChain, isHTokenSend = false) {
        return __awaiter(this, void 0, void 0, function* () {
            amountIn = ethers_1.BigNumber.from(amountIn);
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const hTokenAmount = yield this.calcToHTokenAmount(amountIn, sourceChain);
            const amountOutWithoutFeePromise = this.calcFromHTokenAmount(hTokenAmount, destinationChain);
            const amountInNoSlippage = ethers_1.BigNumber.from(1000);
            const amountOutNoSlippagePromise = this.getAmountOut(amountInNoSlippage, sourceChain, destinationChain);
            const bonderFeeRelativePromise = this.getBonderFeeRelative(amountIn, sourceChain, destinationChain);
            const destinationTxFeePromise = this.getDestinationTransactionFee(sourceChain, destinationChain);
            const [amountOutWithoutFee, amountOutNoSlippage, bonderFeeRelative, destinationTxFee] = yield Promise.all([
                amountOutWithoutFeePromise,
                amountOutNoSlippagePromise,
                bonderFeeRelativePromise,
                destinationTxFeePromise
            ]);
            const amountOut = yield this.calcFromHTokenAmount(hTokenAmount, destinationChain);
            let adjustedBonderFee;
            let adjustedDestinationTxFee;
            let totalFee;
            if (sourceChain.isL1) {
                // there are no Hop fees when the source is L1
                adjustedBonderFee = ethers_1.BigNumber.from(0);
                adjustedDestinationTxFee = ethers_1.BigNumber.from(0);
                totalFee = ethers_1.BigNumber.from(0);
            }
            else {
                if (isHTokenSend) {
                    // fees do not need to be adjusted for AMM slippage when sending hTokens
                    adjustedBonderFee = bonderFeeRelative;
                    adjustedDestinationTxFee = destinationTxFee;
                }
                else {
                    // adjusted fee is the fee in the canonical token after adjusting for the hToken price
                    adjustedBonderFee = yield this.calcFromHTokenAmount(bonderFeeRelative, destinationChain);
                    adjustedDestinationTxFee = yield this.calcFromHTokenAmount(destinationTxFee, destinationChain);
                }
                // enforce bonderFeeAbsolute after adjustment
                const bonderFeeAbsolute = yield this.getBonderFeeAbsolute();
                adjustedBonderFee = adjustedBonderFee.gt(bonderFeeAbsolute)
                    ? adjustedBonderFee
                    : bonderFeeAbsolute;
                totalFee = adjustedBonderFee.add(adjustedDestinationTxFee);
            }
            const sourceToken = this.getCanonicalToken(sourceChain);
            const destToken = this.getCanonicalToken(destinationChain);
            const rate = this.getRate(amountIn, amountOutWithoutFee, sourceToken, destToken);
            const marketRate = this.getRate(amountInNoSlippage, amountOutNoSlippage, sourceToken, destToken);
            const priceImpact = this.getPriceImpact(rate, marketRate);
            const lpFees = yield this.getLpFees(amountIn, sourceChain, destinationChain);
            let estimatedReceived = amountOut;
            if (totalFee.gt(0)) {
                estimatedReceived = estimatedReceived.sub(totalFee);
            }
            if (estimatedReceived.lt(0)) {
                estimatedReceived = ethers_1.BigNumber.from(0);
            }
            return {
                amountOut,
                rate,
                priceImpact,
                requiredLiquidity: hTokenAmount,
                lpFees,
                adjustedBonderFee,
                adjustedDestinationTxFee,
                totalFee,
                estimatedReceived
            };
        });
    }
    // ToDo: Docs
    getAmmData(chain, amountIn, isToHToken, slippageTolerance) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            amountIn = ethers_1.BigNumber.from(amountIn);
            const canonicalToken = this.getCanonicalToken(chain);
            const hToken = this.getL2HopToken(chain);
            const sourceToken = isToHToken ? canonicalToken : hToken;
            const destToken = isToHToken ? hToken : canonicalToken;
            const amountInNoSlippage = ethers_1.BigNumber.from(1000);
            let amountOut;
            let amountOutNoSlippage;
            if (isToHToken) {
                amountOut = yield this.calcToHTokenAmount(amountIn, chain);
                amountOutNoSlippage = yield this.calcToHTokenAmount(amountInNoSlippage, chain);
            }
            else {
                amountOut = yield this.calcFromHTokenAmount(amountIn, chain);
                amountOutNoSlippage = yield this.calcFromHTokenAmount(amountInNoSlippage, chain);
            }
            const rate = this.getRate(amountIn, amountOut, sourceToken, destToken);
            const marketRate = this.getRate(amountInNoSlippage, amountOutNoSlippage, sourceToken, destToken);
            const priceImpact = this.getPriceImpact(rate, marketRate);
            const oneDestBN = ethers_1.ethers.utils.parseUnits('1', sourceToken.decimals);
            const slippageToleranceBps = slippageTolerance * 100;
            const minBps = Math.ceil(10000 - slippageToleranceBps);
            const amountOutMin = amountOut.mul(minBps).div(10000);
            // Divide by 10000 at the end so that the amount isn't floored at 0
            const lpFee = ethers_1.BigNumber.from(constants_1.LpFeeBps);
            const lpFeeBN = (0, utils_1.parseUnits)(lpFee.toString(), destToken.decimals);
            const lpFeeAmount = amountIn
                .mul(lpFeeBN)
                .div(oneDestBN)
                .div(10000);
            return {
                rate,
                priceImpact,
                amountOutMin,
                lpFeeAmount
            };
        });
    }
    getTotalFee(amountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            const { totalFee } = yield this.getSendData(amountIn, sourceChain, destinationChain);
            return totalFee;
        });
    }
    getLpFees(amountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            let lpFeeBpsBn = ethers_1.BigNumber.from(0);
            if (!sourceChain.isL1) {
                lpFeeBpsBn = lpFeeBpsBn.add(constants_1.LpFeeBps);
            }
            if (!destinationChain.isL1) {
                lpFeeBpsBn = lpFeeBpsBn.add(constants_1.LpFeeBps);
            }
            amountIn = ethers_1.BigNumber.from(amountIn);
            const lpFees = amountIn.mul(lpFeeBpsBn).div(10000);
            return lpFees;
        });
    }
    getDestinationTransactionFee(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (sourceChain === null || sourceChain === void 0 ? void 0 : sourceChain.equals(Chain_1.default.Ethereum)) {
                return ethers_1.BigNumber.from(0);
            }
            const canonicalToken = this.getCanonicalToken(sourceChain);
            const chainNativeToken = this.getChainNativeToken(destinationChain);
            const chainNativeTokenPrice = yield this.priceFeed.getPriceByTokenSymbol(chainNativeToken.symbol);
            const tokenPrice = yield this.priceFeed.getPriceByTokenSymbol(canonicalToken.symbol);
            const rate = chainNativeTokenPrice / tokenPrice;
            let gasPrice = yield destinationChain.provider.getGasPrice();
            let bondTransferGasLimit = yield this.estimateBondWithdrawalGasLimit(sourceChain, destinationChain);
            // Arbitrum returns a gasLimit & gasPriceBid of appx 1.5x what is generally paid
            if (destinationChain.equals(Chain_1.default.Arbitrum)) {
                gasPrice = gasPrice.mul(10).div(15);
                bondTransferGasLimit = bondTransferGasLimit.mul(10).div(15);
            }
            // Include the cost to settle an individual transfer
            const settlementGasLimitPerTx = constants_1.SettlementGasLimitPerTx[destinationChain.slug];
            const bondTransferGasLimitWithSettlement = bondTransferGasLimit.add(settlementGasLimitPerTx);
            let txFeeEth = gasPrice.mul(bondTransferGasLimitWithSettlement);
            const oneEth = ethers_1.ethers.utils.parseEther('1');
            const rateBN = ethers_1.ethers.utils.parseUnits(rate.toFixed(canonicalToken.decimals), canonicalToken.decimals);
            if (destinationChain.equals(Chain_1.default.Optimism)) {
                const l1FeeInWei = yield this.getOptimismL1Fee(sourceChain, destinationChain);
                txFeeEth = txFeeEth.add(l1FeeInWei);
            }
            let fee = txFeeEth.mul(rateBN).div(oneEth);
            if (destinationChain.equals(Chain_1.default.Ethereum) ||
                destinationChain.equals(Chain_1.default.Optimism) ||
                destinationChain.equals(Chain_1.default.Arbitrum)) {
                const multiplier = ethers_1.ethers.utils.parseEther(this.destinationFeeGasPriceMultiplier.toString());
                if (multiplier.gt(0)) {
                    fee = fee.mul(multiplier).div(oneEth);
                }
            }
            return fee;
        });
    }
    getOptimismL1Fee(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const [gasLimit, { data, to }] = yield Promise.all([
                    this.estimateBondWithdrawalGasLimit(sourceChain, destinationChain),
                    this.populateBondWithdrawalTx(sourceChain, destinationChain)
                ]);
                const l1FeeInWei = yield this.estimateOptimismL1FeeFromData(gasLimit, data, to);
                return l1FeeInWei;
            }
            catch (err) {
                console.error(err);
                return ethers_1.BigNumber.from(0);
            }
        });
    }
    estimateBondWithdrawalGasLimit(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            destinationChain = this.toChainModel(destinationChain);
            try {
                const populatedTx = yield this.populateBondWithdrawalTx(sourceChain, destinationChain);
                const estimatedGas = yield destinationChain.provider.estimateGas(populatedTx);
                return estimatedGas;
            }
            catch (err) {
                console.error(err, {
                    destinationChain
                });
                let bondTransferGasLimit = constants_1.BondTransferGasLimit.Ethereum;
                if (destinationChain.equals(Chain_1.default.Optimism)) {
                    bondTransferGasLimit = constants_1.BondTransferGasLimit.Optimism;
                }
                else if (destinationChain.equals(Chain_1.default.Arbitrum)) {
                    bondTransferGasLimit = constants_1.BondTransferGasLimit.Arbitrum;
                }
                return ethers_1.BigNumber.from(bondTransferGasLimit);
            }
        });
    }
    populateBondWithdrawalTx(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            destinationChain = this.toChainModel(destinationChain);
            let destinationBridge;
            if (destinationChain.isL1) {
                destinationBridge = yield this.getL1Bridge();
            }
            else {
                destinationBridge = yield this.getL2Bridge(destinationChain);
            }
            destinationBridge = destinationBridge.connect(destinationChain.provider);
            const bonder = this.getBonderAddress(sourceChain, destinationChain);
            const amount = ethers_1.BigNumber.from(10);
            const amountOutMin = ethers_1.BigNumber.from(0);
            const bonderFee = ethers_1.BigNumber.from(1);
            const deadline = this.defaultDeadlineSeconds;
            const transferNonce = `0x${'0'.repeat(64)}`;
            const recipient = `0x${'1'.repeat(40)}`;
            const attemptSwap = this.shouldAttemptSwap(amountOutMin, deadline);
            if (attemptSwap && !destinationChain.isL1) {
                const payload = [
                    recipient,
                    amount,
                    transferNonce,
                    bonderFee,
                    amountOutMin,
                    deadline,
                    {
                        from: bonder
                    }
                ];
                return destinationBridge.populateTransaction.bondWithdrawalAndDistribute(...payload);
            }
            else {
                const payload = [
                    recipient,
                    amount,
                    transferNonce,
                    bonderFee,
                    {
                        from: bonder
                    }
                ];
                return destinationBridge.populateTransaction.bondWithdrawal(...payload);
            }
        });
    }
    /**
     * @desc Estimate token amount out.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge('USDC')
     *const amountOut = await bridge.getAmountOut('1000000000000000000', Chain.Optimism, Chain.Gnosis)
     *console.log(amountOut)
     *```
     */
    getAmountOut(tokenAmountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmountIn = ethers_1.BigNumber.from(tokenAmountIn.toString());
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const hTokenAmount = yield this.calcToHTokenAmount(tokenAmountIn, sourceChain);
            const amountOut = yield this.calcFromHTokenAmount(hTokenAmount, destinationChain);
            return amountOut;
        });
    }
    /**
     * @desc Estimate the bonder liquidity needed at the destination.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge('USDC')
     *const requiredLiquidity = await bridge.getRequiredLiquidity('1000000000000000000', Chain.Optimism, Chain.Gnosis)
     *console.log(requiredLiquidity)
     *```
     */
    getRequiredLiquidity(tokenAmountIn, sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmountIn = ethers_1.BigNumber.from(tokenAmountIn.toString());
            sourceChain = this.toChainModel(sourceChain);
            if (sourceChain.equals(Chain_1.default.Ethereum)) {
                return ethers_1.BigNumber.from(0);
            }
            const hTokenAmount = yield this.calcToHTokenAmount(tokenAmountIn, sourceChain);
            return hTokenAmount;
        });
    }
    getAvailableLiquidity(destinationChain, bonder) {
        return __awaiter(this, void 0, void 0, function* () {
            const [credit, debit] = yield Promise.all([
                this.getCredit(destinationChain, bonder),
                this.getTotalDebit(destinationChain, bonder)
            ]);
            const availableLiquidity = credit.sub(debit);
            return availableLiquidity;
        });
    }
    /**
     * @desc Returns available liquidity for Hop bridge at specified chain.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Available liquidity as BigNumber.
     */
    getFrontendAvailableLiquidity(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const token = this.toTokenModel(this.tokenSymbol);
            const bonder = this.getBonderAddress(sourceChain, destinationChain);
            let availableLiquidity = yield this.getBaseAvailableCreditIncludingVault(sourceChain, destinationChain);
            // fetch on-chain if the data is not available from worker json file
            if (availableLiquidity == null) {
                availableLiquidity = yield this.getAvailableLiquidity(destinationChain, bonder);
            }
            const unbondedTransferRootAmount = yield this.getUnbondedTransferRootAmount(sourceChain, destinationChain);
            if (destinationChain.isL1) {
                let pendingAmounts = ethers_1.BigNumber.from(0);
                for (const bondableChain of config_1.bondableChains) {
                    const l2BridgeAddress = this.getL2BridgeAddress(this.tokenSymbol, bondableChain);
                    if (l2BridgeAddress) {
                        const bondableBridge = yield this.getBridgeContract(bondableChain);
                        const pendingAmount = yield bondableBridge.pendingAmountForChainId(Chain_1.default.Ethereum.chainId);
                        pendingAmounts = pendingAmounts.add(pendingAmount);
                    }
                }
                const tokenPrice = yield this.priceFeed.getPriceByTokenSymbol(token.canonicalSymbol);
                const tokenPriceBn = (0, utils_1.parseUnits)(tokenPrice.toString(), token.decimals);
                const bufferAmountBn = (0, utils_1.parseUnits)(constants_1.PendingAmountBuffer, token.decimals);
                const precision = (0, utils_1.parseUnits)('1', token.decimals);
                const bufferAmountTokensBn = bufferAmountBn.div(tokenPriceBn).mul(precision);
                availableLiquidity = availableLiquidity
                    .sub(pendingAmounts)
                    .sub(unbondedTransferRootAmount)
                    .sub(bufferAmountTokensBn);
                if (this.isOruToL1(sourceChain, destinationChain)) {
                    availableLiquidity = availableLiquidity.div(2);
                }
            }
            if (availableLiquidity.lt(0)) {
                return ethers_1.BigNumber.from(0);
            }
            return availableLiquidity;
        });
    }
    isOruToL1(sourceChain, destinationChain) {
        return destinationChain.isL1 && config_1.bondableChains.includes(sourceChain.slug);
    }
    getBonderAvailableLiquidityData() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `https://assets.hop.exchange/${this.network}/v1-available-liquidity.json`;
            const res = yield (0, isomorphic_fetch_1.default)(url);
            const json = yield res.json();
            if (!json) {
                throw new Error('expected json object');
            }
            const { timestamp, data } = json;
            const tenMinutes = 10 * 60 * 1000;
            const isOutdated = Date.now() - timestamp > tenMinutes;
            if (isOutdated) {
                return;
            }
            return data;
        });
    }
    getUnbondedTransferRootAmount(sourceChain, destinationChain) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            try {
                const data = yield this.getBonderAvailableLiquidityData();
                if (data) {
                    const tokenData = data === null || data === void 0 ? void 0 : data[this.tokenSymbol];
                    const _unbondedTransferRootAmount = (_b = (_a = tokenData === null || tokenData === void 0 ? void 0 : tokenData.unbondedTransferRootAmounts) === null || _a === void 0 ? void 0 : _a[sourceChain.slug]) === null || _b === void 0 ? void 0 : _b[destinationChain.slug];
                    if (_unbondedTransferRootAmount) {
                        return ethers_1.BigNumber.from(_unbondedTransferRootAmount);
                    }
                }
            }
            catch (err) {
                console.error(err);
            }
            return ethers_1.BigNumber.from(0);
        });
    }
    getBaseAvailableCreditIncludingVault(sourceChain, destinationChain) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            try {
                const data = yield this.getBonderAvailableLiquidityData();
                if (data) {
                    const tokenData = data === null || data === void 0 ? void 0 : data[this.tokenSymbol];
                    const _baseAvailableCreditIncludingVault = (_b = (_a = tokenData === null || tokenData === void 0 ? void 0 : tokenData.baseAvailableCreditIncludingVault) === null || _a === void 0 ? void 0 : _a[sourceChain.slug]) === null || _b === void 0 ? void 0 : _b[destinationChain.slug];
                    if (_baseAvailableCreditIncludingVault) {
                        return ethers_1.BigNumber.from(_baseAvailableCreditIncludingVault);
                    }
                }
            }
            catch (err) {
                console.error(err);
            }
        });
    }
    getVaultBalance(destinationChain, bonder) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            destinationChain = this.toChainModel(destinationChain);
            try {
                const data = yield this.getBonderAvailableLiquidityData();
                if (data) {
                    const tokenData = data === null || data === void 0 ? void 0 : data[this.tokenSymbol];
                    const _vaultBalance = (_b = (_a = tokenData === null || tokenData === void 0 ? void 0 : tokenData.bonderVaultBalance) === null || _a === void 0 ? void 0 : _a[bonder]) === null || _b === void 0 ? void 0 : _b[destinationChain.slug];
                    if (_vaultBalance) {
                        return ethers_1.BigNumber.from(_vaultBalance);
                    }
                }
            }
            catch (err) {
                console.error(err);
            }
            return ethers_1.BigNumber.from(0);
        });
    }
    /**
     * @desc Returns bridge contract instance for specified chain.
     * @param {Object} chain - chain model.
     * @returns {Object} Ethers contract instance.
     */
    getBridgeContract(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            let bridge;
            if (chain.isL1) {
                bridge = yield this.getL1Bridge();
            }
            else {
                bridge = yield this.getL2Bridge(chain);
            }
            return bridge;
        });
    }
    /**
     * @desc Returns total credit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total credit as BigNumber.
     */
    getCredit(sourceChain, bonder) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getBridgeContract(sourceChain);
            return bridge.getCredit(bonder);
        });
    }
    /**
     * @desc Returns total debit, including sliding window debit, that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getTotalDebit(sourceChain, bonder) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getBridgeContract(sourceChain);
            return bridge.getDebitAndAdditionalDebit(bonder);
        });
    }
    /**
     * @desc Returns total debit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getDebit(sourceChain, bonder) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getBridgeContract(sourceChain);
            return bridge.getRawDebit(bonder);
        });
    }
    /**
     * @desc Sends transaction to execute swap on Saddle contract.
     * @param {Object} sourceChain - Source chain model.
     * @param {Boolean} toHop - Converts to Hop token only if set to true.
     * @param {Object} amount - Amount of token to swap.
     * @param {Object} minAmountOut - Minimum amount of tokens to receive in order
     * for transaction to be successful.
     * @param {Number} deadline - Transaction deadline in seconds.
     * @returns {Object} Ethers transaction object.
     */
    execSaddleSwap(sourceChain, toHop, amount, minAmountOut, deadline) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            let tokenIndexFrom;
            let tokenIndexTo;
            const l2CanonicalTokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, sourceChain);
            if (!l2CanonicalTokenAddress) {
                throw new Error(`source chain "${sourceChain.slug}" is unsupported`);
            }
            const l2HopBridgeTokenAddress = this.getL2HopBridgeTokenAddress(this.tokenSymbol, sourceChain);
            if (!l2HopBridgeTokenAddress) {
                throw new Error(`source chain "${sourceChain.slug}" is unsupported`);
            }
            const amm = yield this.getAmm(sourceChain);
            const saddleSwap = yield amm.getSaddleSwap();
            const canonicalTokenIndex = Number((yield saddleSwap.getTokenIndex(l2CanonicalTokenAddress)).toString());
            const hopTokenIndex = Number((yield saddleSwap.getTokenIndex(l2HopBridgeTokenAddress)).toString());
            if (toHop) {
                tokenIndexFrom = canonicalTokenIndex;
                tokenIndexTo = hopTokenIndex;
            }
            else {
                tokenIndexFrom = hopTokenIndex;
                tokenIndexTo = canonicalTokenIndex;
            }
            return saddleSwap.swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline);
        });
    }
    /**
     * @desc Returns Hop L1 Bridge Ethers contract instance.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL1Bridge(signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridgeAddress = this.getL1BridgeAddress(this.tokenSymbol, Chain_1.default.Ethereum);
            if (!bridgeAddress) {
                throw new Error(`token "${this.tokenSymbol}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(Chain_1.default.Ethereum, signer);
            return L1ERC20Bridge__factory_1.L1ERC20Bridge__factory.connect(bridgeAddress, provider);
        });
    }
    /**
     * @desc Returns Hop L2 Bridge Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL2Bridge(chain, signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const bridgeAddress = this.getL2BridgeAddress(this.tokenSymbol, chain);
            if (!bridgeAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(chain, signer);
            return L2Bridge__factory_1.L2Bridge__factory.connect(bridgeAddress, provider);
        });
    }
    // ToDo: Docs
    getAmm(chain) {
        chain = this.toChainModel(chain);
        if (chain.isL1) {
            throw new Error('No AMM exists on L1');
        }
        return new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer);
    }
    /**
     * @desc Returns Hop Bridge AMM wrapper Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getAmmWrapper(chain, signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const ammWrapperAddress = this.getL2AmmWrapperAddress(this.tokenSymbol, chain);
            if (!ammWrapperAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(chain, signer);
            return L2AmmWrapper__factory_1.L2AmmWrapper__factory.connect(ammWrapperAddress, provider);
        });
    }
    /**
     * @desc Returns Hop Bridge Saddle reserve amounts.
     * @param {Object} chain - Chain model.
     * @returns {Array} Array containing reserve amounts for canonical token
     * and hTokens.
     */
    getSaddleSwapReserves(chain = this.sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            return Promise.all([
                saddleSwap.getTokenBalance(0),
                saddleSwap.getTokenBalance(1)
            ]);
        });
    }
    getReservesTotal(chain = this.sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            const [reserve0, reserve1] = yield this.getSaddleSwapReserves(chain);
            return reserve0.add(reserve1);
        });
    }
    /**
     * @desc Returns Hop Bridge Saddle Swap LP Token Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getSaddleLpToken(chain, signer = this.signer) {
        // ToDo: Remove ability to pass in signer like other token getters
        chain = this.toChainModel(chain);
        const saddleLpTokenAddress = this.getL2SaddleLpTokenAddress(this.tokenSymbol, chain);
        if (!saddleLpTokenAddress) {
            throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
        }
        // ToDo: Get actual saddle LP token symbol and name
        return new Token_1.default(this.network, chain, saddleLpTokenAddress, 18, `${this.tokenSymbol} LP`, `${this.tokenSymbol} LP`, '', signer, this.chainProviders);
    }
    /**
     * @desc Sends transaction to add liquidity to AMM.
     * @param {Object} amount0Desired - Amount of token #0 in smallest unit
     * @param {Object} amount1Desired - Amount of token #1 in smallest unit
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    addLiquidity(amount0Desired, amount1Desired, chain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            amount0Desired = ethers_1.BigNumber.from(amount0Desired.toString());
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.addLiquidity(amount0Desired, amount1Desired, options.minToMint, options.deadline);
        });
    }
    /**
     * @desc Sends transaction to remove liquidity from AMM.
     * @param {Object} liquidityTokenAmount - Amount of LP tokens to burn.
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    removeLiquidity(liquidityTokenAmount, chain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.removeLiquidity(liquidityTokenAmount, options.amount0Min, options.amount1Min, options.deadline);
        });
    }
    removeLiquidityOneToken(lpTokenAmount, tokenIndex, chain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.removeLiquidityOneToken(lpTokenAmount, tokenIndex, options === null || options === void 0 ? void 0 : options.amountMin, options === null || options === void 0 ? void 0 : options.deadline);
        });
    }
    removeLiquidityImbalance(token0Amount, token1Amount, chain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.removeLiquidityImbalance(token0Amount, token1Amount, options === null || options === void 0 ? void 0 : options.maxBurnAmount, options === null || options === void 0 ? void 0 : options.deadline);
        });
    }
    calculateWithdrawOneToken(tokenAmount, tokenIndex, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.calculateRemoveLiquidityOneToken(tokenAmount, tokenIndex);
        });
    }
    /**
     * @readonly
     * @desc The default deadline to use in seconds.
     * @returns {Number} Deadline in seconds
     */
    get defaultDeadlineSeconds() {
        return (Date.now() / 1000 + this.defaultDeadlineMinutes * 60) | 0;
    }
    /**
     * @readonly
     * @desc The time slot for the current time.
     * @param {Object} time - Unix timestamp (in seconds) to get the time slot.
     * @returns {Object} Time slot for the given time as BigNumber.
     */
    getTimeSlot(time) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            time = ethers_1.BigNumber.from(time.toString());
            return bridge.getTimeSlot(time);
        });
    }
    /**
     * @readonly
     * @desc The challenge period.
     * @returns {Object} The challenge period for the bridge as BigNumber.
     */
    challengePeriod() {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            return bridge.challengePeriod();
        });
    }
    /**
     * @readonly
     * @desc The size of the time slots.
     * @returns {Object} The size of the time slots for the bridge as BigNumber.
     */
    timeSlotSize() {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            return bridge.TIME_SLOT_SIZE();
        });
    }
    /**
     * @readonly
     * @desc The amount bonded for a time slot for a bonder.
     * @param {Object} chain - Chain model.
     * @param {Number} timeSlot - Time slot to get.
     * @param {String} bonder - Address of the bonder to check.
     * @returns {Object} Amount bonded for the bonder for the given time slot as BigNumber.
     */
    timeSlotToAmountBonded(timeSlot, bonder) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            timeSlot = ethers_1.BigNumber.from(timeSlot.toString());
            return bridge.timeSlotToAmountBonded(timeSlot, bonder);
        });
    }
    getTokenIndexes(path, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            const tokenIndexFrom = Number((yield saddleSwap.getTokenIndex(path[0])).toString());
            const tokenIndexTo = Number((yield saddleSwap.getTokenIndex(path[1])).toString());
            return [tokenIndexFrom, tokenIndexTo];
        });
    }
    populateSendL1ToL2Tx(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let { destinationChain, sourceChain, relayer, relayerFee, amount, amountOutMin, deadline, recipient, checkAllowance } = input;
            if (!sourceChain.isL1) {
                // ToDo: Don't pass in sourceChain since it will always be L1
                throw new Error('sourceChain must be L1');
            }
            const destinationChainId = destinationChain.chainId;
            deadline = deadline === undefined ? this.defaultDeadlineSeconds : deadline;
            amountOutMin = ethers_1.BigNumber.from((amountOutMin || 0).toString());
            recipient = recipient || (yield this.getSignerAddress());
            if (!recipient) {
                throw new Error('recipient is required');
            }
            recipient = (0, utils_1.getAddress)(recipient);
            const isNativeToken = this.isNativeToken(sourceChain);
            let l1Bridge = yield this.getL1Bridge(sourceChain.provider);
            if (checkAllowance) {
                this.checkConnectedChain(this.signer, sourceChain);
                l1Bridge = yield this.getL1Bridge(this.signer);
                if (!isNativeToken) {
                    const l1Token = this.getL1Token();
                    const allowance = yield l1Token.allowance(l1Bridge.address);
                    if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                        throw new Error(constants_1.Errors.NotEnoughAllowance);
                    }
                }
            }
            if (amountOutMin.lt(0)) {
                amountOutMin = ethers_1.BigNumber.from(0);
            }
            const txOptions = [
                destinationChainId,
                recipient,
                amount || 0,
                amountOutMin,
                deadline,
                relayer,
                relayerFee || 0,
                Object.assign(Object.assign({}, (yield this.txOverrides(Chain_1.default.Ethereum))), { value: isNativeToken ? amount : undefined })
            ];
            return l1Bridge.populateTransaction.sendToL2(...txOptions);
        });
    }
    populateSendL2ToL1Tx(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let { destinationChain, sourceChain, amount, destinationAmountOutMin, bonderFee, recipient, amountOutMin, deadline, destinationDeadline, checkAllowance } = input;
            const destinationChainId = destinationChain.chainId;
            deadline = deadline === undefined ? this.defaultDeadlineSeconds : deadline;
            amountOutMin = ethers_1.BigNumber.from((amountOutMin || 0).toString());
            destinationDeadline = destinationDeadline || 0;
            destinationAmountOutMin = ethers_1.BigNumber.from((destinationAmountOutMin || 0).toString());
            if (destinationChain.isL1) {
                const attemptSwap = this.shouldAttemptSwap(destinationAmountOutMin, destinationDeadline);
                if (attemptSwap) {
                    throw new Error('"destinationAmountOutMin" and "destinationDeadline" must be 0 when sending to an L1');
                }
            }
            recipient = recipient || (yield this.getSignerAddress());
            if (!recipient) {
                throw new Error('recipient is required');
            }
            recipient = (0, utils_1.getAddress)(recipient);
            let ammWrapper = yield this.getAmmWrapper(sourceChain, sourceChain.provider);
            let l2Bridge = yield this.getL2Bridge(sourceChain, sourceChain.provider);
            const attemptSwapAtSource = this.shouldAttemptSwap(amountOutMin, deadline);
            const spender = attemptSwapAtSource ? ammWrapper.address : l2Bridge.address;
            if (ethers_1.BigNumber.from(bonderFee).gt(amount)) {
                throw new Error(`amount must be greater than bonder fee. amount: ${amount.toString()}, bonderFee: ${bonderFee.toString()}`);
            }
            const isNativeToken = this.isNativeToken(sourceChain);
            if (checkAllowance) {
                this.checkConnectedChain(this.signer, sourceChain);
                ammWrapper = yield this.getAmmWrapper(sourceChain, this.signer);
                l2Bridge = yield this.getL2Bridge(sourceChain, this.signer);
                if (!isNativeToken) {
                    const l2CanonicalToken = this.getCanonicalToken(sourceChain);
                    const allowance = yield l2CanonicalToken.allowance(spender);
                    if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                        throw new Error(constants_1.Errors.NotEnoughAllowance);
                    }
                }
            }
            if (amountOutMin.lt(0)) {
                amountOutMin = ethers_1.BigNumber.from(0);
            }
            if (destinationAmountOutMin.lt(0)) {
                destinationAmountOutMin = ethers_1.BigNumber.from(0);
            }
            const txOptions = [
                destinationChainId,
                recipient,
                amount,
                bonderFee,
                amountOutMin,
                deadline
            ];
            if (attemptSwapAtSource) {
                const additionalOptions = [
                    destinationAmountOutMin,
                    destinationDeadline,
                    Object.assign(Object.assign({}, (yield this.txOverrides(sourceChain))), { value: isNativeToken ? amount : undefined })
                ];
                return ammWrapper.populateTransaction.swapAndSend(...txOptions, ...additionalOptions);
            }
            return l2Bridge.populateTransaction.send(...txOptions, Object.assign(Object.assign({}, (yield this.txOverrides(sourceChain))), { value: isNativeToken ? amount : undefined }));
        });
    }
    populateSendL2ToL2Tx(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let { destinationChain, sourceChain, amount, destinationAmountOutMin, bonderFee, deadline, destinationDeadline, amountOutMin, recipient, checkAllowance } = input;
            const destinationChainId = destinationChain.chainId;
            deadline = deadline || this.defaultDeadlineSeconds;
            destinationDeadline = destinationDeadline || this.defaultDeadlineSeconds;
            amountOutMin = ethers_1.BigNumber.from((amountOutMin || 0).toString());
            destinationAmountOutMin = ethers_1.BigNumber.from((destinationAmountOutMin || 0).toString());
            if (ethers_1.BigNumber.from(bonderFee).gt(amount)) {
                throw new Error('Amount must be greater than bonder fee');
            }
            recipient = recipient || (yield this.getSignerAddress());
            if (!recipient) {
                throw new Error('recipient is required');
            }
            recipient = (0, utils_1.getAddress)(recipient);
            let ammWrapper = yield this.getAmmWrapper(sourceChain, sourceChain.provider);
            const isNativeToken = this.isNativeToken(sourceChain);
            if (checkAllowance) {
                this.checkConnectedChain(this.signer, sourceChain);
                ammWrapper = yield this.getAmmWrapper(sourceChain, this.signer);
                if (!isNativeToken) {
                    const l2CanonicalToken = this.getCanonicalToken(sourceChain);
                    const allowance = yield l2CanonicalToken.allowance(ammWrapper.address);
                    if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                        throw new Error(constants_1.Errors.NotEnoughAllowance);
                    }
                }
            }
            if (amountOutMin.lt(0)) {
                amountOutMin = ethers_1.BigNumber.from(0);
            }
            if (destinationAmountOutMin.lt(0)) {
                destinationAmountOutMin = ethers_1.BigNumber.from(0);
            }
            const txOptions = [
                destinationChainId,
                recipient,
                amount,
                bonderFee,
                amountOutMin,
                deadline,
                destinationAmountOutMin,
                destinationDeadline,
                Object.assign(Object.assign({}, (yield this.txOverrides(sourceChain))), { value: isNativeToken ? amount : undefined })
            ];
            return ammWrapper.populateTransaction.swapAndSend(...txOptions);
        });
    }
    calcToHTokenAmount(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = ethers_1.BigNumber.from(amount.toString());
            if (chain.isL1) {
                return amount;
            }
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            if (amount.eq(0)) {
                return ethers_1.BigNumber.from(0);
            }
            const amountOut = yield saddleSwap.calculateSwap(constants_1.TokenIndex.CanonicalToken, constants_1.TokenIndex.HopBridgeToken, amount);
            return amountOut;
        });
    }
    calcFromHTokenAmount(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = ethers_1.BigNumber.from(amount.toString());
            if (chain.isL1) {
                return ethers_1.BigNumber.from(amount);
            }
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            if (amount.eq(0)) {
                return ethers_1.BigNumber.from(0);
            }
            const amountOut = yield saddleSwap.calculateSwap(constants_1.TokenIndex.HopBridgeToken, constants_1.TokenIndex.CanonicalToken, amount);
            return amountOut;
        });
    }
    getBonderFeeRelative(amountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (sourceChain.isL1) {
                return ethers_1.BigNumber.from(0);
            }
            const hTokenAmount = yield this.calcToHTokenAmount(amountIn.toString(), sourceChain);
            const feeBps = this.getFeeBps(this.tokenSymbol, destinationChain);
            const bonderFeeRelative = hTokenAmount.mul(feeBps).div(10000);
            return bonderFeeRelative;
        });
    }
    getBonderFeeAbsolute() {
        return __awaiter(this, void 0, void 0, function* () {
            const token = this.toTokenModel(this.tokenSymbol);
            const tokenPrice = yield this.priceFeed.getPriceByTokenSymbol(token.symbol);
            const minBonderFeeUsd = 0.25;
            const bonderFeeAbsolute = (0, utils_1.parseUnits)((minBonderFeeUsd / tokenPrice).toFixed(token.decimals), token.decimals);
            return bonderFeeAbsolute;
        });
    }
    getRate(amountIn, amountOut, sourceToken, destToken) {
        let rateBN;
        if (amountIn.eq(0)) {
            rateBN = ethers_1.BigNumber.from(0);
        }
        else {
            const oneSourceBN = ethers_1.ethers.utils.parseUnits('1', sourceToken.decimals);
            rateBN = amountOut.mul(oneSourceBN).div(amountIn);
        }
        const rate = Number(ethers_1.ethers.utils.formatUnits(rateBN, destToken.decimals));
        return rate;
    }
    getPriceImpact(rate, marketRate) {
        return ((marketRate - rate) / marketRate) * 100;
    }
    checkConnectedChain(signer, chain) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const connectedChainId = yield ((_a = signer) === null || _a === void 0 ? void 0 : _a.getChainId());
            if (connectedChainId !== chain.chainId) {
                throw new Error('invalid connected chain ID. Make sure signer provider is connected to source chain network');
            }
        });
    }
    // Gnosis AMB bridge
    getAmbBridge(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            if (chain.equals(Chain_1.default.Ethereum)) {
                const address = this.getL1AmbBridgeAddress(this.tokenSymbol, Chain_1.default.Gnosis);
                const provider = yield this.getSignerOrProvider(Chain_1.default.Ethereum);
                return L1HomeAMBNativeToErc20__factory_1.L1HomeAMBNativeToErc20__factory.connect(address, provider);
            }
            const address = this.getL2AmbBridgeAddress(this.tokenSymbol, Chain_1.default.Gnosis);
            const provider = yield this.getSignerOrProvider(Chain_1.default.Gnosis);
            return L1HomeAMBNativeToErc20__factory_1.L1HomeAMBNativeToErc20__factory.connect(address, provider);
        });
    }
    getChainNativeToken(chain) {
        chain = this.toChainModel(chain);
        if (chain === null || chain === void 0 ? void 0 : chain.equals(Chain_1.default.Polygon)) {
            return this.toTokenModel(constants_1.CanonicalToken.MATIC);
        }
        else if (chain === null || chain === void 0 ? void 0 : chain.equals(Chain_1.default.Gnosis)) {
            return this.toTokenModel(constants_1.CanonicalToken.DAI);
        }
        return this.toTokenModel(constants_1.CanonicalToken.ETH);
    }
    isNativeToken(chain) {
        const token = this.getCanonicalToken(chain || this.sourceChain);
        return token.isNativeToken;
    }
    getEthBalance(chain = this.sourceChain, address) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            address = address !== null && address !== void 0 ? address : yield this.getSignerAddress();
            if (!address) {
                throw new Error('address is required');
            }
            return chain.provider.getBalance(address);
        });
    }
    isSupportedAsset(chain) {
        var _a;
        chain = this.toChainModel(chain);
        const supported = this.getSupportedAssets();
        return !!((_a = supported[chain.slug]) === null || _a === void 0 ? void 0 : _a[this.tokenSymbol]);
    }
    getBonderAddress(sourceChain, destinationChain) {
        return this._getBonderAddress(this.tokenSymbol, sourceChain, destinationChain);
    }
    shouldAttemptSwap(amountOutMin, deadline) {
        deadline = ethers_1.BigNumber.from((deadline === null || deadline === void 0 ? void 0 : deadline.toString()) || 0);
        return (amountOutMin === null || amountOutMin === void 0 ? void 0 : amountOutMin.gt(0)) || (deadline === null || deadline === void 0 ? void 0 : deadline.gt(0));
    }
    getGasEstimateFromAddress(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            let address = yield this.getSignerAddress();
            if (!address) {
                address = yield this.getBonderAddress(sourceChain, destinationChain);
            }
            return address;
        });
    }
    withdraw(chain, recipient, amount, transferNonce, bonderFee, amountOutMin, deadline, transferRootHash, rootTotalAmount, transferIdTreeIndex, siblings, totalLeaves) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const txOptions = [
                recipient,
                amount,
                transferNonce,
                bonderFee,
                amountOutMin,
                deadline,
                transferRootHash,
                rootTotalAmount,
                transferIdTreeIndex,
                siblings,
                totalLeaves,
                yield this.txOverrides(chain)
            ];
            this.checkConnectedChain(this.signer, chain);
            const bridge = yield this.getBridgeContract(chain);
            return bridge.withdraw(...txOptions);
        });
    }
}
exports.default = HopBridge;
