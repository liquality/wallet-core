import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface StakingRewardsInterface extends utils.Interface {
    contractName: "StakingRewards";
    functions: {
        "balanceOf(address)": FunctionFragment;
        "earned(address)": FunctionFragment;
        "exit()": FunctionFragment;
        "getReward()": FunctionFragment;
        "getRewardForDuration()": FunctionFragment;
        "lastTimeRewardApplicable()": FunctionFragment;
        "lastUpdateTime()": FunctionFragment;
        "notifyRewardAmount(uint256)": FunctionFragment;
        "periodFinish()": FunctionFragment;
        "rewardPerToken()": FunctionFragment;
        "rewardPerTokenStored()": FunctionFragment;
        "rewardRate()": FunctionFragment;
        "rewards(address)": FunctionFragment;
        "rewardsDistribution()": FunctionFragment;
        "rewardsDuration()": FunctionFragment;
        "rewardsToken()": FunctionFragment;
        "stake(uint256)": FunctionFragment;
        "stakeWithPermit(uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
        "stakingToken()": FunctionFragment;
        "totalSupply()": FunctionFragment;
        "userRewardPerTokenPaid(address)": FunctionFragment;
        "withdraw(uint256)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
    encodeFunctionData(functionFragment: "earned", values: [string]): string;
    encodeFunctionData(functionFragment: "exit", values?: undefined): string;
    encodeFunctionData(functionFragment: "getReward", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRewardForDuration", values?: undefined): string;
    encodeFunctionData(functionFragment: "lastTimeRewardApplicable", values?: undefined): string;
    encodeFunctionData(functionFragment: "lastUpdateTime", values?: undefined): string;
    encodeFunctionData(functionFragment: "notifyRewardAmount", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "periodFinish", values?: undefined): string;
    encodeFunctionData(functionFragment: "rewardPerToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "rewardPerTokenStored", values?: undefined): string;
    encodeFunctionData(functionFragment: "rewardRate", values?: undefined): string;
    encodeFunctionData(functionFragment: "rewards", values: [string]): string;
    encodeFunctionData(functionFragment: "rewardsDistribution", values?: undefined): string;
    encodeFunctionData(functionFragment: "rewardsDuration", values?: undefined): string;
    encodeFunctionData(functionFragment: "rewardsToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "stake", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "stakeWithPermit", values: [BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "stakingToken", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSupply", values?: undefined): string;
    encodeFunctionData(functionFragment: "userRewardPerTokenPaid", values: [string]): string;
    encodeFunctionData(functionFragment: "withdraw", values: [BigNumberish]): string;
    decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "earned", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "exit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getReward", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRewardForDuration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lastTimeRewardApplicable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lastUpdateTime", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "notifyRewardAmount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "periodFinish", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewardPerToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewardPerTokenStored", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewardRate", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewards", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewardsDistribution", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewardsDuration", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rewardsToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stakeWithPermit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stakingToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSupply", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "userRewardPerTokenPaid", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
    events: {
        "RewardAdded(uint256)": EventFragment;
        "RewardPaid(address,uint256)": EventFragment;
        "Staked(address,uint256)": EventFragment;
        "Withdrawn(address,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "RewardAdded"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RewardPaid"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Staked"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}
export declare type RewardAddedEvent = TypedEvent<[BigNumber], {
    reward: BigNumber;
}>;
export declare type RewardAddedEventFilter = TypedEventFilter<RewardAddedEvent>;
export declare type RewardPaidEvent = TypedEvent<[
    string,
    BigNumber
], {
    user: string;
    reward: BigNumber;
}>;
export declare type RewardPaidEventFilter = TypedEventFilter<RewardPaidEvent>;
export declare type StakedEvent = TypedEvent<[
    string,
    BigNumber
], {
    user: string;
    amount: BigNumber;
}>;
export declare type StakedEventFilter = TypedEventFilter<StakedEvent>;
export declare type WithdrawnEvent = TypedEvent<[
    string,
    BigNumber
], {
    user: string;
    amount: BigNumber;
}>;
export declare type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;
export interface StakingRewards extends BaseContract {
    contractName: "StakingRewards";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: StakingRewardsInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        balanceOf(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        earned(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        exit(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getReward(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getRewardForDuration(overrides?: CallOverrides): Promise<[BigNumber]>;
        lastTimeRewardApplicable(overrides?: CallOverrides): Promise<[BigNumber]>;
        lastUpdateTime(overrides?: CallOverrides): Promise<[BigNumber]>;
        notifyRewardAmount(reward: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        periodFinish(overrides?: CallOverrides): Promise<[BigNumber]>;
        rewardPerToken(overrides?: CallOverrides): Promise<[BigNumber]>;
        rewardPerTokenStored(overrides?: CallOverrides): Promise<[BigNumber]>;
        rewardRate(overrides?: CallOverrides): Promise<[BigNumber]>;
        rewards(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        rewardsDistribution(overrides?: CallOverrides): Promise<[string]>;
        rewardsDuration(overrides?: CallOverrides): Promise<[BigNumber]>;
        rewardsToken(overrides?: CallOverrides): Promise<[string]>;
        stake(amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        stakeWithPermit(amount: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        stakingToken(overrides?: CallOverrides): Promise<[string]>;
        totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;
        userRewardPerTokenPaid(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        withdraw(amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;
    earned(account: string, overrides?: CallOverrides): Promise<BigNumber>;
    exit(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getReward(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getRewardForDuration(overrides?: CallOverrides): Promise<BigNumber>;
    lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;
    lastUpdateTime(overrides?: CallOverrides): Promise<BigNumber>;
    notifyRewardAmount(reward: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    periodFinish(overrides?: CallOverrides): Promise<BigNumber>;
    rewardPerToken(overrides?: CallOverrides): Promise<BigNumber>;
    rewardPerTokenStored(overrides?: CallOverrides): Promise<BigNumber>;
    rewardRate(overrides?: CallOverrides): Promise<BigNumber>;
    rewards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    rewardsDistribution(overrides?: CallOverrides): Promise<string>;
    rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;
    rewardsToken(overrides?: CallOverrides): Promise<string>;
    stake(amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    stakeWithPermit(amount: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    stakingToken(overrides?: CallOverrides): Promise<string>;
    totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
    userRewardPerTokenPaid(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
    withdraw(amount: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        earned(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        exit(overrides?: CallOverrides): Promise<void>;
        getReward(overrides?: CallOverrides): Promise<void>;
        getRewardForDuration(overrides?: CallOverrides): Promise<BigNumber>;
        lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;
        lastUpdateTime(overrides?: CallOverrides): Promise<BigNumber>;
        notifyRewardAmount(reward: BigNumberish, overrides?: CallOverrides): Promise<void>;
        periodFinish(overrides?: CallOverrides): Promise<BigNumber>;
        rewardPerToken(overrides?: CallOverrides): Promise<BigNumber>;
        rewardPerTokenStored(overrides?: CallOverrides): Promise<BigNumber>;
        rewardRate(overrides?: CallOverrides): Promise<BigNumber>;
        rewards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        rewardsDistribution(overrides?: CallOverrides): Promise<string>;
        rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;
        rewardsToken(overrides?: CallOverrides): Promise<string>;
        stake(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;
        stakeWithPermit(amount: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: CallOverrides): Promise<void>;
        stakingToken(overrides?: CallOverrides): Promise<string>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
        userRewardPerTokenPaid(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        withdraw(amount: BigNumberish, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "RewardAdded(uint256)"(reward?: null): RewardAddedEventFilter;
        RewardAdded(reward?: null): RewardAddedEventFilter;
        "RewardPaid(address,uint256)"(user?: string | null, reward?: null): RewardPaidEventFilter;
        RewardPaid(user?: string | null, reward?: null): RewardPaidEventFilter;
        "Staked(address,uint256)"(user?: string | null, amount?: null): StakedEventFilter;
        Staked(user?: string | null, amount?: null): StakedEventFilter;
        "Withdrawn(address,uint256)"(user?: string | null, amount?: null): WithdrawnEventFilter;
        Withdrawn(user?: string | null, amount?: null): WithdrawnEventFilter;
    };
    estimateGas: {
        balanceOf(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        earned(account: string, overrides?: CallOverrides): Promise<BigNumber>;
        exit(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getReward(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getRewardForDuration(overrides?: CallOverrides): Promise<BigNumber>;
        lastTimeRewardApplicable(overrides?: CallOverrides): Promise<BigNumber>;
        lastUpdateTime(overrides?: CallOverrides): Promise<BigNumber>;
        notifyRewardAmount(reward: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        periodFinish(overrides?: CallOverrides): Promise<BigNumber>;
        rewardPerToken(overrides?: CallOverrides): Promise<BigNumber>;
        rewardPerTokenStored(overrides?: CallOverrides): Promise<BigNumber>;
        rewardRate(overrides?: CallOverrides): Promise<BigNumber>;
        rewards(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        rewardsDistribution(overrides?: CallOverrides): Promise<BigNumber>;
        rewardsDuration(overrides?: CallOverrides): Promise<BigNumber>;
        rewardsToken(overrides?: CallOverrides): Promise<BigNumber>;
        stake(amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        stakeWithPermit(amount: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        stakingToken(overrides?: CallOverrides): Promise<BigNumber>;
        totalSupply(overrides?: CallOverrides): Promise<BigNumber>;
        userRewardPerTokenPaid(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        withdraw(amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        balanceOf(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        earned(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        exit(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getReward(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getRewardForDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lastTimeRewardApplicable(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lastUpdateTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        notifyRewardAmount(reward: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        periodFinish(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewardPerToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewardPerTokenStored(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewardRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewards(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewardsDistribution(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewardsDuration(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rewardsToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        stake(amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        stakeWithPermit(amount: BigNumberish, deadline: BigNumberish, v: BigNumberish, r: BytesLike, s: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        stakingToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        userRewardPerTokenPaid(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        withdraw(amount: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
//# sourceMappingURL=StakingRewards.d.ts.map