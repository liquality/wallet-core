import BN from 'bn.js';
import { Contract } from 'web3-eth-contract';
import ContractsBase from '../common/ContractsBase';
import Web3Client from '../common/Web3Client';
import { address, MaticClientInitializationOptions, SendOptions } from '../types/Common';
import RootChain from './RootChain';
export default class POSRootChainManager extends ContractsBase {
    posRootChainManager: Contract;
    private exitManager;
    private erc20Predicate;
    private erc721Predicate;
    private erc1155Predicate;
    private erc1155MintablePredicate;
    private rootTunnelContractAbi;
    requestConcurrency: number | null;
    private formatUint256;
    constructor(options: MaticClientInitializationOptions, rootChain: RootChain, web3Client: Web3Client);
    getPredicateAddress(rootToken: address): Promise<any>;
    depositEtherForUser(amount: BN | string, user: address, options?: SendOptions): Promise<any>;
    depositFor(user: address, rootToken: address, depositData: string, options?: SendOptions): Promise<any>;
    exit(burnTxHash: string, logSignature: string, options?: SendOptions): Promise<any>;
    exitFastMerkle(start: any, end: any, blockNumber: any): Promise<any>;
    exitHermoine(burnTxHash: string, logSignature: string, options?: SendOptions): Promise<any>;
    getERC20ExitPayload(burnTxHash: string): Promise<any>;
    isExitProcessed(burnTxHash: string, logSignature: string): Promise<any>;
    processReceivedMessage(contractAddress: address, txHash: string, options?: SendOptions): Promise<any>;
    customPayload(txHash: string, eventSig: string): Promise<any>;
    approveERC20(rootToken: address, amount: BN | string, options?: SendOptions): Promise<any>;
    approveMaxERC20(rootToken: address, options?: SendOptions): Promise<any>;
    allowanceOfERC20(userAddress: address, token: address, options?: SendOptions): Promise<any>;
    depositERC20ForUser(rootToken: address, amount: BN | string, user: address, options?: SendOptions): Promise<any>;
    burnERC20(childToken: address, amount: BN | string, options?: SendOptions): Promise<any>;
    exitERC20(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitERC20Hermoine(burnTxHash: string, options?: SendOptions): Promise<any>;
    isERC20ExitProcessed(burnTxHash: string): Promise<any>;
    approveERC721(rootToken: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    isApprovedERC721(token: address, tokenId: BN | string, options?: SendOptions): Promise<boolean>;
    approveAllERC721(rootToken: address, options?: SendOptions): Promise<any>;
    isApprovedForAllERC721(token: address, userAddress: address, options?: SendOptions): Promise<any>;
    depositERC721ForUser(rootToken: address, tokenId: BN | string, user: address, options?: SendOptions): Promise<any>;
    depositBatchERC721ForUser(rootToken: address, tokenIds: (BN | string)[], user: address, options?: SendOptions): Promise<any>;
    burnERC721(childToken: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    burnWithMetadataERC721(childToken: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    burnBatchERC721(childToken: address, tokenIds: (BN | string)[], options?: SendOptions): Promise<any>;
    exitERC721(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitBatchERC721(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitERC721WithMetadata(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitERC721WithMetadataHermoine(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitBatchERC721Hermoine(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitERC721Hermoine(burnTxHash: string, options?: SendOptions): Promise<any>;
    isERC721ExitProcessed(burnTxHash: string): Promise<any>;
    isBatchERC721ExitProcessed(burnTxHash: string): Promise<any>;
    approveERC1155(rootToken: address, options?: SendOptions): Promise<any>;
    approveMintableERC1155(rootToken: address, options?: SendOptions): Promise<any>;
    depositSingleERC1155ForUser(rootToken: address, tokenId: BN | string, amount: BN | string, user: address, data?: string, options?: SendOptions): Promise<any>;
    depositBatchERC1155ForUser(rootToken: address, tokenIds: (BN | string)[], amounts: (BN | string)[], user: address, data?: string, options?: SendOptions): Promise<any>;
    burnSingleERC1155(childToken: address, tokenId: BN | string, amount: BN | string, options?: SendOptions): Promise<any>;
    burnBatchERC1155(childToken: address, tokenIds: (BN | string)[], amounts: (BN | string)[], options?: SendOptions): Promise<any>;
    exitSingleERC1155(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitSingleERC1155Hermoine(burnTxHash: string, options?: SendOptions): Promise<any>;
    isSingleERC1155ExitProcessed(burnTxHash: string): Promise<any>;
    exitBatchERC1155(burnTxHash: string, options?: SendOptions): Promise<any>;
    exitBatchERC1155Hermoine(burnTxHash: string, options?: SendOptions): Promise<any>;
    isBatchERC1155ExitProcessed(burnTxHash: string): Promise<any>;
    mintERC721(childToken: address, userAddress: address, tokenId: BN | string, options?: SendOptions): Promise<any>;
    mintERC1155(childToken: address, userAddress: address, tokenId: BN | string, amount: BN | string, data?: string, options?: SendOptions): Promise<any>;
    mintBatchERC1155ForUser(childToken: address, tokenIds: (BN | string)[], amounts: (BN | string)[], userAddress: address, data?: string, options?: SendOptions): Promise<any>;
}
